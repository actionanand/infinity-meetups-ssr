import { i as identity, a as is_function, S as SvelteComponentDev, b as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, v as validate_slots, e as element, f as claim_element, g as children, h as detach_dev, j as attr_dev, k as add_location, l as insert_hydration_dev, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, t as transition_in, o as add_render_callback, p as create_bidirectional_transition, q as transition_out, r as globals, w as createEventDispatcher, x as create_component, y as claim_component, z as mount_component, A as destroy_component, B as text, C as space, D as claim_text, E as claim_space, F as src_url_equal, G as append_hydration_dev, H as set_data_dev, I as group_outros, J as check_outros, K as noop, L as toggle_class, M as listen_dev, N as run_all, O as bubble, P as prop_dev, Q as prevent_default, R as onMount, T as onDestroy, U as empty, V as query_selector_all, W as validate_each_argument, X as validate_each_keys, Y as fix_position, Z as add_transform, _ as create_animation, $ as update_keyed_each, a0 as fix_and_outro_and_destroy_block } from './client.f9df6ebb.js';
import { B as Button, m as meetups } from './Button.cac47677.js';

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}

function flip(node, { from, to }, params = {}) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
    const dx = (from.left + from.width * ox / to.width) - (to.left + ox);
    const dy = (from.top + from.height * oy / to.height) - (to.top + oy);
    const { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
        easing,
        css: (t, u) => {
            const x = u * dx;
            const y = u * dy;
            const sx = t + u * from.width / to.width;
            const sy = t + u * from.height / to.height;
            return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
        }
    };
}

/* src/components/UI/Badge.svelte generated by Svelte v3.46.3 */
const file = "src/components/UI/Badge.svelte";

function create_fragment(ctx) {
	let span;
	let span_transition;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1yf4dvc");
			add_location(span, file, 18, 0, 324);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!span_transition) span_transition = create_bidirectional_transition(span, slide, {}, true);
				span_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			if (!span_transition) span_transition = create_bidirectional_transition(span, slide, {}, false);
			span_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			if (detaching && span_transition) span_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Badge', slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ slide });
	return [$$scope, slots];
}

class Badge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badge",
			options,
			id: create_fragment.name
		});
	}
}

/* src/components/Meetup/MeetupItem.svelte generated by Svelte v3.46.3 */

const { Error: Error_1, console: console_1 } = globals;
const file$1 = "src/components/Meetup/MeetupItem.svelte";

// (112:6) {#if isFav}
function create_if_block_1(ctx) {
	let badge;
	let current;

	badge = new Badge({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(badge.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(badge, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(112:6) {#if isFav}",
		ctx
	});

	return block;
}

// (113:8) <Badge>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Favorite");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(113:8) <Badge>",
		ctx
	});

	return block;
}

// (127:4) <Button mode="outline" type="button" on:click="{dispatch('edit-meetup', id)}">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Edit");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(127:4) <Button mode=\\\"outline\\\" type=\\\"button\\\" on:click=\\\"{dispatch('edit-meetup', id)}\\\">",
		ctx
	});

	return block;
}

// (130:4) {:else}
function create_else_block(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "button",
				mode: "outline",
				color: /*isFav*/ ctx[6] ? null : 'success',
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*onToggleFavorite*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*isFav*/ 64) button_changes.color = /*isFav*/ ctx[6] ? null : 'success';

			if (dirty & /*$$scope, isFav*/ 4160) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(130:4) {:else}",
		ctx
	});

	return block;
}

// (128:4) {#if isLoading}
function create_if_block(ctx) {
	let span;
	let t0_value = (/*isFav*/ ctx[6] ? 'Unfavoriting' : 'Favoriting') + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = text("...");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_text(span_nodes, "...");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "changing-fav svelte-if5wql");
			add_location(span, file$1, 128, 6, 2461);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*isFav*/ 64 && t0_value !== (t0_value = (/*isFav*/ ctx[6] ? 'Unfavoriting' : 'Favoriting') + "")) set_data_dev(t0, t0_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(128:4) {#if isLoading}",
		ctx
	});

	return block;
}

// (131:6) <Button          type="button"          mode="outline"          color={isFav? null : 'success'}         on:click="{onToggleFavorite}">
function create_default_slot_1(ctx) {
	let t_value = (/*isFav*/ ctx[6] ? 'Unfavorite' : 'Favorite') + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*isFav*/ 64 && t_value !== (t_value = (/*isFav*/ ctx[6] ? 'Unfavorite' : 'Favorite') + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(131:6) <Button          type=\\\"button\\\"          mode=\\\"outline\\\"          color={isFav? null : 'success'}         on:click=\\\"{onToggleFavorite}\\\">",
		ctx
	});

	return block;
}

// (139:4) <Button type="button" on:click="{() => dispatch('show-details', id)}">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Show Details");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Show Details");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(139:4) <Button type=\\\"button\\\" on:click=\\\"{() => dispatch('show-details', id)}\\\">",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let article;
	let header;
	let h1;
	let t0;
	let t1;
	let t2;
	let h2;
	let t3;
	let t4;
	let p0;
	let t5;
	let t6;
	let div0;
	let img;
	let img_src_value;
	let t7;
	let div1;
	let p1;
	let t8;
	let t9;
	let footer;
	let button0;
	let t10;
	let current_block_type_index;
	let if_block1;
	let t11;
	let button1;
	let current;
	let if_block0 = /*isFav*/ ctx[6] && create_if_block_1(ctx);

	button0 = new Button({
			props: {
				mode: "outline",
				type: "button",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", function () {
		if (is_function(/*dispatch*/ ctx[8]('edit-meetup', /*id*/ ctx[5]))) /*dispatch*/ ctx[8]('edit-meetup', /*id*/ ctx[5]).apply(this, arguments);
	});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button1 = new Button({
			props: {
				type: "button",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler*/ ctx[11]);

	const block = {
		c: function create() {
			article = element("article");
			header = element("header");
			h1 = element("h1");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			h2 = element("h2");
			t3 = text(/*subtitle*/ ctx[1]);
			t4 = space();
			p0 = element("p");
			t5 = text(/*address*/ ctx[4]);
			t6 = space();
			div0 = element("div");
			img = element("img");
			t7 = space();
			div1 = element("div");
			p1 = element("p");
			t8 = text(/*description*/ ctx[3]);
			t9 = space();
			footer = element("footer");
			create_component(button0.$$.fragment);
			t10 = space();
			if_block1.c();
			t11 = space();
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			article = claim_element(nodes, "ARTICLE", { class: true });
			var article_nodes = children(article);
			header = claim_element(article_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h1 = claim_element(header_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[0]);
			t1 = claim_space(h1_nodes);
			if (if_block0) if_block0.l(h1_nodes);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(header_nodes);
			h2 = claim_element(header_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t3 = claim_text(h2_nodes, /*subtitle*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			t4 = claim_space(header_nodes);
			p0 = claim_element(header_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t5 = claim_text(p0_nodes, /*address*/ ctx[4]);
			p0_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t6 = claim_space(article_nodes);
			div0 = claim_element(article_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach_dev);
			t7 = claim_space(article_nodes);
			div1 = claim_element(article_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p1 = claim_element(div1_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			t8 = claim_text(p1_nodes, /*description*/ ctx[3]);
			p1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t9 = claim_space(article_nodes);
			footer = claim_element(article_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			claim_component(button0.$$.fragment, footer_nodes);
			t10 = claim_space(footer_nodes);
			if_block1.l(footer_nodes);
			t11 = claim_space(footer_nodes);
			claim_component(button1.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			article_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-if5wql");
			add_location(h1, file$1, 109, 4, 1989);
			attr_dev(h2, "class", "svelte-if5wql");
			add_location(h2, file$1, 115, 4, 2085);
			attr_dev(p0, "class", "svelte-if5wql");
			add_location(p0, file$1, 116, 4, 2109);
			attr_dev(header, "class", "svelte-if5wql");
			add_location(header, file$1, 108, 2, 1976);
			if (!src_url_equal(img.src, img_src_value = /*imageUrl*/ ctx[2])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", /*title*/ ctx[0]);
			attr_dev(img, "class", "svelte-if5wql");
			add_location(img, file$1, 119, 4, 2164);
			attr_dev(div0, "class", "image svelte-if5wql");
			add_location(div0, file$1, 118, 2, 2140);
			attr_dev(p1, "class", "svelte-if5wql");
			add_location(p1, file$1, 122, 4, 2238);
			attr_dev(div1, "class", "content svelte-if5wql");
			add_location(div1, file$1, 121, 2, 2212);
			attr_dev(footer, "class", "svelte-if5wql");
			add_location(footer, file$1, 124, 2, 2270);
			attr_dev(article, "class", "svelte-if5wql");
			add_location(article, file$1, 107, 0, 1964);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, article, anchor);
			append_hydration_dev(article, header);
			append_hydration_dev(header, h1);
			append_hydration_dev(h1, t0);
			append_hydration_dev(h1, t1);
			if (if_block0) if_block0.m(h1, null);
			append_hydration_dev(header, t2);
			append_hydration_dev(header, h2);
			append_hydration_dev(h2, t3);
			append_hydration_dev(header, t4);
			append_hydration_dev(header, p0);
			append_hydration_dev(p0, t5);
			append_hydration_dev(article, t6);
			append_hydration_dev(article, div0);
			append_hydration_dev(div0, img);
			append_hydration_dev(article, t7);
			append_hydration_dev(article, div1);
			append_hydration_dev(div1, p1);
			append_hydration_dev(p1, t8);
			append_hydration_dev(article, t9);
			append_hydration_dev(article, footer);
			mount_component(button0, footer, null);
			append_hydration_dev(footer, t10);
			if_blocks[current_block_type_index].m(footer, null);
			append_hydration_dev(footer, t11);
			mount_component(button1, footer, null);
			current = true;
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

			if (/*isFav*/ ctx[6]) {
				if (if_block0) {
					if (dirty & /*isFav*/ 64) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(h1, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*subtitle*/ 2) set_data_dev(t3, /*subtitle*/ ctx[1]);
			if (!current || dirty & /*address*/ 16) set_data_dev(t5, /*address*/ ctx[4]);

			if (!current || dirty & /*imageUrl*/ 4 && !src_url_equal(img.src, img_src_value = /*imageUrl*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*title*/ 1) {
				attr_dev(img, "alt", /*title*/ ctx[0]);
			}

			if (!current || dirty & /*description*/ 8) set_data_dev(t8, /*description*/ ctx[3]);
			const button0_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(footer, t11);
			}

			const button1_changes = {};

			if (dirty & /*$$scope*/ 4096) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(button0.$$.fragment, local);
			transition_in(if_block1);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(button0.$$.fragment, local);
			transition_out(if_block1);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(article);
			if (if_block0) if_block0.d();
			destroy_component(button0);
			if_blocks[current_block_type_index].d();
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MeetupItem', slots, []);
	let { title } = $$props;
	let { subtitle } = $$props;
	let { imageUrl } = $$props;
	let { description } = $$props;
	let { address } = $$props;
	let { email } = $$props;
	let { id } = $$props;
	let { isFav } = $$props;
	let isLoading = false;
	const dispatch = createEventDispatcher();

	function onToggleFavorite() {
		$$invalidate(7, isLoading = true);

		fetch(`https://vue-http-exmp-default-rtdb.firebaseio.com/meetups/${id}.json`, {
			method: 'PATCH',
			body: JSON.stringify({ isFavorite: !isFav }),
			headers: { 'Content-Type': 'application/json' }
		}).then(res => {
			if (!res.ok) {
				throw new Error('Error changing favorite status!');
			}

			$$invalidate(7, isLoading = false);
			meetups.toggleFavorite(id);
		}).catch(err => {
			$$invalidate(7, isLoading = false);
			console.log(err);
		});
	}

	const writable_props = [
		'title',
		'subtitle',
		'imageUrl',
		'description',
		'address',
		'email',
		'id',
		'isFav'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<MeetupItem> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch('show-details', id);

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
		if ('imageUrl' in $$props) $$invalidate(2, imageUrl = $$props.imageUrl);
		if ('description' in $$props) $$invalidate(3, description = $$props.description);
		if ('address' in $$props) $$invalidate(4, address = $$props.address);
		if ('email' in $$props) $$invalidate(10, email = $$props.email);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('isFav' in $$props) $$invalidate(6, isFav = $$props.isFav);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		meetups,
		Button,
		Badge,
		title,
		subtitle,
		imageUrl,
		description,
		address,
		email,
		id,
		isFav,
		isLoading,
		dispatch,
		onToggleFavorite
	});

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
		if ('imageUrl' in $$props) $$invalidate(2, imageUrl = $$props.imageUrl);
		if ('description' in $$props) $$invalidate(3, description = $$props.description);
		if ('address' in $$props) $$invalidate(4, address = $$props.address);
		if ('email' in $$props) $$invalidate(10, email = $$props.email);
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('isFav' in $$props) $$invalidate(6, isFav = $$props.isFav);
		if ('isLoading' in $$props) $$invalidate(7, isLoading = $$props.isLoading);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		title,
		subtitle,
		imageUrl,
		description,
		address,
		id,
		isFav,
		isLoading,
		dispatch,
		onToggleFavorite,
		email,
		click_handler
	];
}

class MeetupItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			title: 0,
			subtitle: 1,
			imageUrl: 2,
			description: 3,
			address: 4,
			email: 10,
			id: 5,
			isFav: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MeetupItem",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'title'");
		}

		if (/*subtitle*/ ctx[1] === undefined && !('subtitle' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'subtitle'");
		}

		if (/*imageUrl*/ ctx[2] === undefined && !('imageUrl' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'imageUrl'");
		}

		if (/*description*/ ctx[3] === undefined && !('description' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'description'");
		}

		if (/*address*/ ctx[4] === undefined && !('address' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'address'");
		}

		if (/*email*/ ctx[10] === undefined && !('email' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'email'");
		}

		if (/*id*/ ctx[5] === undefined && !('id' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'id'");
		}

		if (/*isFav*/ ctx[6] === undefined && !('isFav' in props)) {
			console_1.warn("<MeetupItem> was created without expected prop 'isFav'");
		}
	}

	get title() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imageUrl() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imageUrl(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get description() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set description(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get address() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set address(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get email() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set email(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isFav() {
		throw new Error_1("<MeetupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isFav(value) {
		throw new Error_1("<MeetupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Meetup/MeetupFilter.svelte generated by Svelte v3.46.3 */
const file$2 = "src/components/Meetup/MeetupFilter.svelte";

function create_fragment$2(ctx) {
	let div;
	let button0;
	let t0;
	let t1;
	let button1;
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			button0 = element("button");
			t0 = text("All");
			t1 = space();
			button1 = element("button");
			t2 = text("Favorite");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			button0 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button0_nodes = children(button0);
			t0 = claim_text(button0_nodes, "All");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			button1 = claim_element(div_nodes, "BUTTON", { type: true, class: true });
			var button1_nodes = children(button1);
			t2 = claim_text(button1_nodes, "Favorite");
			button1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button0, "type", "button");
			attr_dev(button0, "class", "svelte-wewm0q");
			toggle_class(button0, "active", /*selectedButton*/ ctx[0] === 'all-meetup');
			add_location(button0, file$2, 9, 2, 161);
			attr_dev(button1, "type", "button");
			attr_dev(button1, "class", "svelte-wewm0q");
			toggle_class(button1, "active", /*selectedButton*/ ctx[0] === 'fav-meetup');
			add_location(button1, file$2, 14, 2, 357);
			attr_dev(div, "class", "svelte-wewm0q");
			add_location(div, file$2, 8, 0, 153);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, button0);
			append_hydration_dev(button0, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, button1);
			append_hydration_dev(button1, t2);

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*selectedButton*/ 1) {
				toggle_class(button0, "active", /*selectedButton*/ ctx[0] === 'all-meetup');
			}

			if (dirty & /*selectedButton*/ 1) {
				toggle_class(button1, "active", /*selectedButton*/ ctx[0] === 'fav-meetup');
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MeetupFilter', slots, []);
	const dispatch = createEventDispatcher();
	let selectedButton = 'all-meetup';
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeetupFilter> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		$$invalidate(0, selectedButton = 'all-meetup');
		dispatch('select-component', 'all-meetup');
	};

	const click_handler_1 = () => {
		$$invalidate(0, selectedButton = 'fav-meetup');
		dispatch('select-component', 'fav-meetup');
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		dispatch,
		selectedButton
	});

	$$self.$inject_state = $$props => {
		if ('selectedButton' in $$props) $$invalidate(0, selectedButton = $$props.selectedButton);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [selectedButton, dispatch, click_handler, click_handler_1];
}

class MeetupFilter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MeetupFilter",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/components/UI/TextInput.svelte generated by Svelte v3.46.3 */

const file$3 = "src/components/UI/TextInput.svelte";

// (21:2) {:else}
function create_else_block$1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				id: true,
				placeholder: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", /*type*/ ctx[6]);
			attr_dev(input, "name", /*id*/ ctx[1]);
			attr_dev(input, "id", /*id*/ ctx[1]);
			attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
			input.value = /*value*/ ctx[5];
			attr_dev(input, "class", "svelte-nbe6ea");
			toggle_class(input, "invalid", !/*valid*/ ctx[7] && /*touched*/ ctx[9]);
			add_location(input, file$3, 21, 6, 585);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_handler_1*/ ctx[11], false, false, false),
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*type*/ 64) {
				attr_dev(input, "type", /*type*/ ctx[6]);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(input, "name", /*id*/ ctx[1]);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(input, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*placeholder*/ 16) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty & /*value*/ 32 && input.value !== /*value*/ ctx[5]) {
				prop_dev(input, "value", /*value*/ ctx[5]);
			}

			if (dirty & /*valid, touched*/ 640) {
				toggle_class(input, "invalid", !/*valid*/ ctx[7] && /*touched*/ ctx[9]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(21:2) {:else}",
		ctx
	});

	return block;
}

// (17:2) {#if controlType === 'textarea'}
function create_if_block_1$1(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				name: true,
				id: true,
				rows: true,
				placeholder: true,
				class: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(textarea, "name", /*id*/ ctx[1]);
			attr_dev(textarea, "id", /*id*/ ctx[1]);
			attr_dev(textarea, "rows", /*row*/ ctx[3]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[4]);
			textarea.value = /*value*/ ctx[5];
			attr_dev(textarea, "class", "svelte-nbe6ea");
			toggle_class(textarea, "invalid", !/*valid*/ ctx[7] && /*touched*/ ctx[9]);
			add_location(textarea, file$3, 17, 6, 380);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, textarea, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*input_handler*/ ctx[10], false, false, false),
					listen_dev(textarea, "blur", /*blur_handler*/ ctx[12], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id*/ 2) {
				attr_dev(textarea, "name", /*id*/ ctx[1]);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(textarea, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*row*/ 8) {
				attr_dev(textarea, "rows", /*row*/ ctx[3]);
			}

			if (dirty & /*placeholder*/ 16) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty & /*value*/ 32) {
				prop_dev(textarea, "value", /*value*/ ctx[5]);
			}

			if (dirty & /*valid, touched*/ 640) {
				toggle_class(textarea, "invalid", !/*valid*/ ctx[7] && /*touched*/ ctx[9]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(17:2) {#if controlType === 'textarea'}",
		ctx
	});

	return block;
}

// (27:2) {#if validityMessage && !valid && touched}
function create_if_block$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*validityMessage*/ ctx[8]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*validityMessage*/ ctx[8]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "error-message svelte-nbe6ea");
			add_location(p, file$3, 27, 4, 827);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*validityMessage*/ 256) set_data_dev(t, /*validityMessage*/ ctx[8]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(27:2) {#if validityMessage && !valid && touched}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let t2;

	function select_block_type(ctx, dirty) {
		if (/*controlType*/ ctx[0] === 'textarea') return create_if_block_1$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*validityMessage*/ ctx[8] && !/*valid*/ ctx[7] && /*touched*/ ctx[9] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			label_1 = element("label");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*label*/ ctx[2]);
			label_1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*id*/ ctx[1]);
			attr_dev(label_1, "class", "svelte-nbe6ea");
			add_location(label_1, file$3, 15, 2, 305);
			attr_dev(div, "class", "form-control svelte-nbe6ea");
			add_location(div, file$3, 14, 0, 276);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, label_1);
			append_hydration_dev(label_1, t0);
			append_hydration_dev(div, t1);
			if_block0.m(div, null);
			append_hydration_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);

			if (dirty & /*id*/ 2) {
				attr_dev(label_1, "for", /*id*/ ctx[1]);
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t2);
				}
			}

			if (/*validityMessage*/ ctx[8] && !/*valid*/ ctx[7] && /*touched*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TextInput', slots, []);
	let { controlType = null } = $$props;
	let { id } = $$props;
	let { label } = $$props;
	let { row = null } = $$props;
	let { placeholder } = $$props;
	let { value } = $$props;
	let { type = 'text' } = $$props;
	let { valid = true } = $$props;
	let { validityMessage = '' } = $$props;
	let touched = false;

	const writable_props = [
		'controlType',
		'id',
		'label',
		'row',
		'placeholder',
		'value',
		'type',
		'valid',
		'validityMessage'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInput> was created with unknown prop '${key}'`);
	});

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const blur_handler = () => $$invalidate(9, touched = true);
	const blur_handler_1 = () => $$invalidate(9, touched = true);

	$$self.$$set = $$props => {
		if ('controlType' in $$props) $$invalidate(0, controlType = $$props.controlType);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('row' in $$props) $$invalidate(3, row = $$props.row);
		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('type' in $$props) $$invalidate(6, type = $$props.type);
		if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
		if ('validityMessage' in $$props) $$invalidate(8, validityMessage = $$props.validityMessage);
	};

	$$self.$capture_state = () => ({
		controlType,
		id,
		label,
		row,
		placeholder,
		value,
		type,
		valid,
		validityMessage,
		touched
	});

	$$self.$inject_state = $$props => {
		if ('controlType' in $$props) $$invalidate(0, controlType = $$props.controlType);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('row' in $$props) $$invalidate(3, row = $$props.row);
		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ('value' in $$props) $$invalidate(5, value = $$props.value);
		if ('type' in $$props) $$invalidate(6, type = $$props.type);
		if ('valid' in $$props) $$invalidate(7, valid = $$props.valid);
		if ('validityMessage' in $$props) $$invalidate(8, validityMessage = $$props.validityMessage);
		if ('touched' in $$props) $$invalidate(9, touched = $$props.touched);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		controlType,
		id,
		label,
		row,
		placeholder,
		value,
		type,
		valid,
		validityMessage,
		touched,
		input_handler,
		input_handler_1,
		blur_handler,
		blur_handler_1
	];
}

class TextInput extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			controlType: 0,
			id: 1,
			label: 2,
			row: 3,
			placeholder: 4,
			value: 5,
			type: 6,
			valid: 7,
			validityMessage: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextInput",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[1] === undefined && !('id' in props)) {
			console.warn("<TextInput> was created without expected prop 'id'");
		}

		if (/*label*/ ctx[2] === undefined && !('label' in props)) {
			console.warn("<TextInput> was created without expected prop 'label'");
		}

		if (/*placeholder*/ ctx[4] === undefined && !('placeholder' in props)) {
			console.warn("<TextInput> was created without expected prop 'placeholder'");
		}

		if (/*value*/ ctx[5] === undefined && !('value' in props)) {
			console.warn("<TextInput> was created without expected prop 'value'");
		}
	}

	get controlType() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set controlType(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get row() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valid() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valid(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validityMessage() {
		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validityMessage(value) {
		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/UI/Modal.svelte generated by Svelte v3.46.3 */
const file$4 = "src/components/UI/Modal.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});

// (71:6) <Button on:click="{closeModal}">
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Close");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Close");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(71:6) <Button on:click=\\\"{closeModal}\\\">",
		ctx
	});

	return block;
}

// (70:24)        
function fallback_block(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*closeModal*/ ctx[1]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 8) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(70:24)        ",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div0;
	let div0_transition;
	let t0;
	let div2;
	let h1;
	let t1;
	let t2;
	let div1;
	let t3;
	let footer;
	let div2_transition;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	const footer_slot_template = /*#slots*/ ctx[2].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context);
	const footer_slot_or_fallback = footer_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div2 = element("div");
			h1 = element("h1");
			t1 = text(/*title*/ ctx[0]);
			t2 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			t3 = space();
			footer = element("footer");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h1 = claim_element(div2_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			footer = claim_element(div2_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			if (footer_slot_or_fallback) footer_slot_or_fallback.l(footer_nodes);
			footer_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-backdrop svelte-17q1g7o");
			add_location(div0, file$4, 62, 0, 998);
			attr_dev(h1, "class", "svelte-17q1g7o");
			add_location(h1, file$4, 64, 2, 1123);
			attr_dev(div1, "class", "content svelte-17q1g7o");
			add_location(div1, file$4, 65, 2, 1142);
			attr_dev(footer, "class", "svelte-17q1g7o");
			add_location(footer, file$4, 68, 2, 1187);
			attr_dev(div2, "class", "modal svelte-17q1g7o");
			add_location(div2, file$4, 63, 0, 1073);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div0, anchor);
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, div2, anchor);
			append_hydration_dev(div2, h1);
			append_hydration_dev(h1, t1);
			append_hydration_dev(div2, t2);
			append_hydration_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration_dev(div2, t3);
			append_hydration_dev(div2, footer);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(footer, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div0, "click", /*closeModal*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data_dev(t1, /*title*/ ctx[0]);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[3], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, true);
				div0_transition.run(1);
			});

			transition_in(default_slot, local);
			transition_in(footer_slot_or_fallback, local);

			add_render_callback(() => {
				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, { y: 300 }, true);
				div2_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, {}, false);
			div0_transition.run(0);
			transition_out(default_slot, local);
			transition_out(footer_slot_or_fallback, local);
			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, { y: 300 }, false);
			div2_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching && div0_transition) div0_transition.end();
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
			if (detaching && div2_transition) div2_transition.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Modal', slots, ['default','footer']);
	let { title } = $$props;
	const dispatch = createEventDispatcher();

	function closeModal() {
		dispatch('cancel');
	}

	const writable_props = ['title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		fly,
		fade,
		Button,
		title,
		dispatch,
		closeModal
	});

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, closeModal, slots, $$scope];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { title: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
			console.warn("<Modal> was created without expected prop 'title'");
		}
	}

	get title() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function isEmpty(val, len) {
  return val.trim().length < len;
}

function isValidEmail(val) {
  return new RegExp(
    "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"
  ).test(val);
}

/* src/components/Meetup/EditMeetup.svelte generated by Svelte v3.46.3 */

const { Error: Error_1$1, console: console_1$1 } = globals;
const file$5 = "src/components/Meetup/EditMeetup.svelte";

// (127:0) <Modal title="Edit Meetup Data" on:cancel>
function create_default_slot_3$1(ctx) {
	let form;
	let textinput0;
	let t0;
	let textinput1;
	let t1;
	let textinput2;
	let t2;
	let textinput3;
	let t3;
	let textinput4;
	let t4;
	let textinput5;
	let current;
	let mounted;
	let dispose;

	textinput0 = new TextInput({
			props: {
				id: "title",
				label: "Title",
				value: /*title*/ ctx[1],
				valid: /*isTitleValid*/ ctx[12],
				validityMessage: "Please enter a valid title",
				placeholder: "Your title goes here"
			},
			$$inline: true
		});

	textinput0.$on("input", /*input_handler*/ ctx[17]);

	textinput1 = new TextInput({
			props: {
				id: "subtitle",
				label: "Subtitle",
				value: /*subtitle*/ ctx[2],
				valid: /*isSubtitleValid*/ ctx[11],
				validityMessage: "Please enter a valid subtitle",
				placeholder: "Your subtitle goes here"
			},
			$$inline: true
		});

	textinput1.$on("input", /*input_handler_1*/ ctx[18]);

	textinput2 = new TextInput({
			props: {
				id: "description",
				label: "Description",
				value: /*desc*/ ctx[5],
				row: "3",
				valid: /*isDescValid*/ ctx[8],
				validityMessage: "Please enter a valid description",
				controlType: "textarea",
				placeholder: "Please add some description"
			},
			$$inline: true
		});

	textinput2.$on("input", /*input_handler_2*/ ctx[19]);

	textinput3 = new TextInput({
			props: {
				id: "imageUrl",
				label: "imageUrl",
				value: /*url*/ ctx[3],
				type: "url",
				valid: /*isUrlValid*/ ctx[10],
				validityMessage: "Please enter a valid image url",
				placeholder: "Please add image url"
			},
			$$inline: true
		});

	textinput3.$on("input", /*input_handler_3*/ ctx[20]);

	textinput4 = new TextInput({
			props: {
				id: "address",
				label: "Address",
				value: /*address*/ ctx[4],
				row: "3",
				valid: /*isAddressValid*/ ctx[9],
				validityMessage: "Please enter a valid address",
				controlType: "textarea",
				placeholder: "Your address goes here"
			},
			$$inline: true
		});

	textinput4.$on("input", /*input_handler_4*/ ctx[21]);

	textinput5 = new TextInput({
			props: {
				id: "email",
				label: "email",
				value: /*email*/ ctx[6],
				type: "email",
				valid: /*isEmailValid*/ ctx[7],
				validityMessage: "Please enter a valid email",
				placeholder: "Your e-mail Id goes here"
			},
			$$inline: true
		});

	textinput5.$on("input", /*input_handler_5*/ ctx[22]);

	const block = {
		c: function create() {
			form = element("form");
			create_component(textinput0.$$.fragment);
			t0 = space();
			create_component(textinput1.$$.fragment);
			t1 = space();
			create_component(textinput2.$$.fragment);
			t2 = space();
			create_component(textinput3.$$.fragment);
			t3 = space();
			create_component(textinput4.$$.fragment);
			t4 = space();
			create_component(textinput5.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", { class: true });
			var form_nodes = children(form);
			claim_component(textinput0.$$.fragment, form_nodes);
			t0 = claim_space(form_nodes);
			claim_component(textinput1.$$.fragment, form_nodes);
			t1 = claim_space(form_nodes);
			claim_component(textinput2.$$.fragment, form_nodes);
			t2 = claim_space(form_nodes);
			claim_component(textinput3.$$.fragment, form_nodes);
			t3 = claim_space(form_nodes);
			claim_component(textinput4.$$.fragment, form_nodes);
			t4 = claim_space(form_nodes);
			claim_component(textinput5.$$.fragment, form_nodes);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form, "class", "svelte-6x27t8");
			add_location(form, file$5, 127, 2, 3368);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, form, anchor);
			mount_component(textinput0, form, null);
			append_hydration_dev(form, t0);
			mount_component(textinput1, form, null);
			append_hydration_dev(form, t1);
			mount_component(textinput2, form, null);
			append_hydration_dev(form, t2);
			mount_component(textinput3, form, null);
			append_hydration_dev(form, t3);
			mount_component(textinput4, form, null);
			append_hydration_dev(form, t4);
			mount_component(textinput5, form, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*submitForm*/ ctx[14]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const textinput0_changes = {};
			if (dirty & /*title*/ 2) textinput0_changes.value = /*title*/ ctx[1];
			if (dirty & /*isTitleValid*/ 4096) textinput0_changes.valid = /*isTitleValid*/ ctx[12];
			textinput0.$set(textinput0_changes);
			const textinput1_changes = {};
			if (dirty & /*subtitle*/ 4) textinput1_changes.value = /*subtitle*/ ctx[2];
			if (dirty & /*isSubtitleValid*/ 2048) textinput1_changes.valid = /*isSubtitleValid*/ ctx[11];
			textinput1.$set(textinput1_changes);
			const textinput2_changes = {};
			if (dirty & /*desc*/ 32) textinput2_changes.value = /*desc*/ ctx[5];
			if (dirty & /*isDescValid*/ 256) textinput2_changes.valid = /*isDescValid*/ ctx[8];
			textinput2.$set(textinput2_changes);
			const textinput3_changes = {};
			if (dirty & /*url*/ 8) textinput3_changes.value = /*url*/ ctx[3];
			if (dirty & /*isUrlValid*/ 1024) textinput3_changes.valid = /*isUrlValid*/ ctx[10];
			textinput3.$set(textinput3_changes);
			const textinput4_changes = {};
			if (dirty & /*address*/ 16) textinput4_changes.value = /*address*/ ctx[4];
			if (dirty & /*isAddressValid*/ 512) textinput4_changes.valid = /*isAddressValid*/ ctx[9];
			textinput4.$set(textinput4_changes);
			const textinput5_changes = {};
			if (dirty & /*email*/ 64) textinput5_changes.value = /*email*/ ctx[6];
			if (dirty & /*isEmailValid*/ 128) textinput5_changes.valid = /*isEmailValid*/ ctx[7];
			textinput5.$set(textinput5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textinput0.$$.fragment, local);
			transition_in(textinput1.$$.fragment, local);
			transition_in(textinput2.$$.fragment, local);
			transition_in(textinput3.$$.fragment, local);
			transition_in(textinput4.$$.fragment, local);
			transition_in(textinput5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textinput0.$$.fragment, local);
			transition_out(textinput1.$$.fragment, local);
			transition_out(textinput2.$$.fragment, local);
			transition_out(textinput3.$$.fragment, local);
			transition_out(textinput4.$$.fragment, local);
			transition_out(textinput5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			destroy_component(textinput0);
			destroy_component(textinput1);
			destroy_component(textinput2);
			destroy_component(textinput3);
			destroy_component(textinput4);
			destroy_component(textinput5);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(127:0) <Modal title=\\\"Edit Meetup Data\\\" on:cancel>",
		ctx
	});

	return block;
}

// (190:4) <Button type="submit" mode="outline" on:click="{onCancel}" >
function create_default_slot_2$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cancel");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(190:4) <Button type=\\\"submit\\\" mode=\\\"outline\\\" on:click=\\\"{onCancel}\\\" >",
		ctx
	});

	return block;
}

// (191:4) <Button type="submit" on:click="{submitForm}" disabled="{!isFormValid}" >
function create_default_slot_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Save");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(191:4) <Button type=\\\"submit\\\" on:click=\\\"{submitForm}\\\" disabled=\\\"{!isFormValid}\\\" >",
		ctx
	});

	return block;
}

// (192:4) {#if id}
function create_if_block$2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "button",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*onDeleteMeetup*/ ctx[16]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 67108864) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(192:4) {#if id}",
		ctx
	});

	return block;
}

// (193:6) <Button type="button" on:click="{onDeleteMeetup}">
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(193:6) <Button type=\\\"button\\\" on:click=\\\"{onDeleteMeetup}\\\">",
		ctx
	});

	return block;
}

// (189:2) 
function create_footer_slot(ctx) {
	let div;
	let button0;
	let t0;
	let button1;
	let t1;
	let current;

	button0 = new Button({
			props: {
				type: "submit",
				mode: "outline",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*onCancel*/ ctx[15]);

	button1 = new Button({
			props: {
				type: "submit",
				disabled: !/*isFormValid*/ ctx[13],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*submitForm*/ ctx[14]);
	let if_block = /*id*/ ctx[0] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(button0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(button1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "footer");
			add_location(div, file$5, 188, 2, 5201);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_hydration_dev(div, t0);
			mount_component(button1, div, null);
			append_hydration_dev(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 67108864) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*isFormValid*/ 8192) button1_changes.disabled = !/*isFormValid*/ ctx[13];

			if (dirty & /*$$scope*/ 67108864) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);

			if (/*id*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*id*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(189:2) ",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let modal;
	let current;

	modal = new Modal({
			props: {
				title: "Edit Meetup Data",
				$$slots: {
					footer: [create_footer_slot],
					default: [create_default_slot_3$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	modal.$on("cancel", /*cancel_handler*/ ctx[23]);

	const block = {
		c: function create() {
			create_component(modal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(modal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const modal_changes = {};

			if (dirty & /*$$scope, id, isFormValid, email, isEmailValid, address, isAddressValid, url, isUrlValid, desc, isDescValid, subtitle, isSubtitleValid, title, isTitleValid*/ 67125247) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let isTitleValid;
	let isSubtitleValid;
	let isUrlValid;
	let isAddressValid;
	let isDescValid;
	let isEmailValid;
	let isFormValid;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditMeetup', slots, []);
	let { id = null } = $$props;
	let title = '';
	let subtitle = '';
	let url = '';
	let address = '';
	let desc = '';
	let email = '';
	const dispatch = createEventDispatcher();

	if (id) {
		const unSub = meetups.subscribe(items => {
			const meetupToBeEdited = items.find(item => item.id === id);
			$$invalidate(1, title = meetupToBeEdited.title);
			$$invalidate(2, subtitle = meetupToBeEdited.subtitle);
			$$invalidate(3, url = meetupToBeEdited.imageUrl);
			$$invalidate(4, address = meetupToBeEdited.address);
			$$invalidate(5, desc = meetupToBeEdited.description);
			$$invalidate(6, email = meetupToBeEdited.contactEmail);
		});

		unSub();
	}

	function sendingErrorMsg(errorMsg) {
		dispatch('error-modal', errorMsg);
	}

	function submitForm() {
		const meetupData = {
			title,
			subtitle,
			imageUrl: url,
			description: desc,
			address,
			contactEmail: email
		};

		if (id) {
			fetch(`https://vue-http-exmp-default-rtdb.firebaseio.com/meetups/${id}.json`, {
				method: 'PATCH',
				body: JSON.stringify(meetupData),
				headers: { 'Content-Type': 'application/json' }
			}).then(res => {
				if (!res.ok) {
					throw new Error('Error editting meetup!');
				}

				console.log('Meetup editted');
				meetups.updateMeetup(id, meetupData);
			}).catch(err => {
				sendingErrorMsg(err.message);
			}); // console.log(err.message);
		} else {
			fetch('https://vue-http-exmp-default-rtdb.firebaseio.com/meetups.json', {
				method: 'POST',
				body: JSON.stringify({ ...meetupData, isFavorite: false }),
				headers: { 'Content-Type': 'application/json' }
			}).then(res => {
				if (!res.ok) {
					throw new Error('Error saving meetup!');
				}

				return res.json();
			}).then(data => {
				console.log('Meetup added :', data);

				meetups.addMeetup({
					...meetupData,
					isFavorite: false,
					id: data.name
				});
			}).catch(err => {
				sendingErrorMsg(err.message);
			}); // console.log(err);
		}

		dispatch('save-form-data');
	}

	function onCancel() {
		dispatch('cancel');
	}

	function onDeleteMeetup() {
		fetch(`https://vue-http-exmp-default-rtdb.firebaseio.com/meetups/${id}.json`, { method: 'DELETE' }).then(res => {
			if (!res.ok) {
				throw new Error('Error deleting meetup!');
			}

			meetups.deleteMeetup(id);
		}).catch(err => {
			// console.log(err);
			sendingErrorMsg(err.message);
		});

		dispatch('save-form-data');
	}

	const writable_props = ['id'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<EditMeetup> was created with unknown prop '${key}'`);
	});

	const input_handler = event => $$invalidate(1, title = event.target.value);
	const input_handler_1 = event => $$invalidate(2, subtitle = event.target.value);
	const input_handler_2 = event => $$invalidate(5, desc = event.target.value);
	const input_handler_3 = event => $$invalidate(3, url = event.target.value);
	const input_handler_4 = event => $$invalidate(4, address = event.target.value);
	const input_handler_5 = event => $$invalidate(6, email = event.target.value);

	function cancel_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		meetups,
		TextInput,
		Button,
		Modal,
		isEmpty,
		isValidEmail,
		id,
		title,
		subtitle,
		url,
		address,
		desc,
		email,
		dispatch,
		sendingErrorMsg,
		submitForm,
		onCancel,
		onDeleteMeetup,
		isEmailValid,
		isDescValid,
		isAddressValid,
		isUrlValid,
		isSubtitleValid,
		isTitleValid,
		isFormValid
	});

	$$self.$inject_state = $$props => {
		if ('id' in $$props) $$invalidate(0, id = $$props.id);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('subtitle' in $$props) $$invalidate(2, subtitle = $$props.subtitle);
		if ('url' in $$props) $$invalidate(3, url = $$props.url);
		if ('address' in $$props) $$invalidate(4, address = $$props.address);
		if ('desc' in $$props) $$invalidate(5, desc = $$props.desc);
		if ('email' in $$props) $$invalidate(6, email = $$props.email);
		if ('isEmailValid' in $$props) $$invalidate(7, isEmailValid = $$props.isEmailValid);
		if ('isDescValid' in $$props) $$invalidate(8, isDescValid = $$props.isDescValid);
		if ('isAddressValid' in $$props) $$invalidate(9, isAddressValid = $$props.isAddressValid);
		if ('isUrlValid' in $$props) $$invalidate(10, isUrlValid = $$props.isUrlValid);
		if ('isSubtitleValid' in $$props) $$invalidate(11, isSubtitleValid = $$props.isSubtitleValid);
		if ('isTitleValid' in $$props) $$invalidate(12, isTitleValid = $$props.isTitleValid);
		if ('isFormValid' in $$props) $$invalidate(13, isFormValid = $$props.isFormValid);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title*/ 2) {
			 $$invalidate(12, isTitleValid = !isEmpty(title, 3));
		}

		if ($$self.$$.dirty & /*subtitle*/ 4) {
			 $$invalidate(11, isSubtitleValid = !isEmpty(subtitle, 3));
		}

		if ($$self.$$.dirty & /*url*/ 8) {
			 $$invalidate(10, isUrlValid = !isEmpty(url, 5));
		}

		if ($$self.$$.dirty & /*address*/ 16) {
			 $$invalidate(9, isAddressValid = !isEmpty(address, 10));
		}

		if ($$self.$$.dirty & /*desc*/ 32) {
			 $$invalidate(8, isDescValid = !isEmpty(desc, 5));
		}

		if ($$self.$$.dirty & /*email*/ 64) {
			 $$invalidate(7, isEmailValid = isValidEmail(email));
		}

		if ($$self.$$.dirty & /*isTitleValid, isSubtitleValid, isUrlValid, isAddressValid, isDescValid, isEmailValid*/ 8064) {
			 $$invalidate(13, isFormValid = isTitleValid && isSubtitleValid && isUrlValid && isAddressValid && isDescValid & isEmailValid);
		}
	};

	return [
		id,
		title,
		subtitle,
		url,
		address,
		desc,
		email,
		isEmailValid,
		isDescValid,
		isAddressValid,
		isUrlValid,
		isSubtitleValid,
		isTitleValid,
		isFormValid,
		submitForm,
		onCancel,
		onDeleteMeetup,
		input_handler,
		input_handler_1,
		input_handler_2,
		input_handler_3,
		input_handler_4,
		input_handler_5,
		cancel_handler
	];
}

class EditMeetup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditMeetup",
			options,
			id: create_fragment$5.name
		});
	}

	get id() {
		throw new Error_1$1("<EditMeetup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error_1$1("<EditMeetup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/UI/LoadingSpinner.svelte generated by Svelte v3.46.3 */

const file$6 = "src/components/UI/LoadingSpinner.svelte";

function create_fragment$6(ctx) {
	let div4;
	let div3;
	let div0;
	let div1;
	let div2;

	const block = {
		c: function create() {
			div4 = element("div");
			div3 = element("div");
			div0 = element("div");
			div1 = element("div");
			div2 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			children(div1).forEach(detach_dev);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			children(div2).forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "svelte-1j1bhq9");
			add_location(div0, file$6, 1, 28, 58);
			attr_dev(div1, "class", "svelte-1j1bhq9");
			add_location(div1, file$6, 1, 39, 69);
			attr_dev(div2, "class", "svelte-1j1bhq9");
			add_location(div2, file$6, 1, 50, 80);
			attr_dev(div3, "class", "lds-facebook svelte-1j1bhq9");
			add_location(div3, file$6, 1, 2, 32);
			attr_dev(div4, "class", "loading-spinner svelte-1j1bhq9");
			add_location(div4, file$6, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div4, anchor);
			append_hydration_dev(div4, div3);
			append_hydration_dev(div3, div0);
			append_hydration_dev(div3, div1);
			append_hydration_dev(div3, div2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LoadingSpinner', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LoadingSpinner> was created with unknown prop '${key}'`);
	});

	return [];
}

class LoadingSpinner extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadingSpinner",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/index.svelte generated by Svelte v3.46.3 */

const { Error: Error_1$2 } = globals;
const file$7 = "src/routes/index.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (128:0) {#if editMode === 'edit'}
function create_if_block_2(ctx) {
	let editmeetup;
	let current;

	editmeetup = new EditMeetup({
			props: { id: /*editedId*/ ctx[1] },
			$$inline: true
		});

	editmeetup.$on("save-form-data", /*onSaveMeetup*/ ctx[5]);
	editmeetup.$on("cancel", /*cancelEdit*/ ctx[6]);
	editmeetup.$on("error-modal", onErrorEditPage);

	const block = {
		c: function create() {
			create_component(editmeetup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editmeetup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editmeetup, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editmeetup_changes = {};
			if (dirty & /*editedId*/ 2) editmeetup_changes.id = /*editedId*/ ctx[1];
			editmeetup.$set(editmeetup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editmeetup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editmeetup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editmeetup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(128:0) {#if editMode === 'edit'}",
		ctx
	});

	return block;
}

// (135:0) {:else}
function create_else_block$2(ctx) {
	let section0;
	let meetupfilter;
	let t0;
	let button;
	let t1;
	let t2;
	let section1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	meetupfilter = new MeetupFilter({ $$inline: true });
	meetupfilter.$on("select-component", /*selectComponent*/ ctx[4]);

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*onAddMeetup*/ ctx[8]);
	let if_block = /*filteredMeetups*/ ctx[2].length === 0 && create_if_block_1$2(ctx);
	let each_value = /*filteredMeetups*/ ctx[2];
	validate_each_argument(each_value);
	const get_key = ctx => /*meetup*/ ctx[14].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			section0 = element("section");
			create_component(meetupfilter.$$.fragment);
			t0 = space();
			create_component(button.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			section1 = element("section");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			section0 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section0_nodes = children(section0);
			claim_component(meetupfilter.$$.fragment, section0_nodes);
			t0 = claim_space(section0_nodes);
			claim_component(button.$$.fragment, section0_nodes);
			section0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			t2 = claim_space(nodes);
			section1 = claim_element(nodes, "SECTION", { id: true, class: true });
			var section1_nodes = children(section1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(section1_nodes);
			}

			section1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section0, "id", "meetup-controls");
			attr_dev(section0, "class", "svelte-18e9u1f");
			add_location(section0, file$7, 135, 2, 3035);
			attr_dev(section1, "id", "meetups");
			attr_dev(section1, "class", "svelte-18e9u1f");
			add_location(section1, file$7, 142, 2, 3301);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section0, anchor);
			mount_component(meetupfilter, section0, null);
			append_hydration_dev(section0, t0);
			mount_component(button, section0, null);
			insert_hydration_dev(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, t2, anchor);
			insert_hydration_dev(target, section1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(section1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (/*filteredMeetups*/ ctx[2].length === 0) {
				if (if_block) ; else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(t2.parentNode, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*filteredMeetups, onEditMeetup*/ 132) {
				each_value = /*filteredMeetups*/ ctx[2];
				validate_each_argument(each_value);
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, section1, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(meetupfilter.$$.fragment, local);
			transition_in(button.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(meetupfilter.$$.fragment, local);
			transition_out(button.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section0);
			destroy_component(meetupfilter);
			destroy_component(button);
			if (detaching) detach_dev(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(section1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(135:0) {:else}",
		ctx
	});

	return block;
}

// (133:0) {#if isLoading}
function create_if_block$3(ctx) {
	let loadingspinner;
	let current;
	loadingspinner = new LoadingSpinner({ $$inline: true });

	const block = {
		c: function create() {
			create_component(loadingspinner.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loadingspinner.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loadingspinner, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loadingspinner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingspinner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingspinner, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(133:0) {#if isLoading}",
		ctx
	});

	return block;
}

// (138:4) <Button on:click="{onAddMeetup}">
function create_default_slot$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("New Meetup");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "New Meetup");
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(138:4) <Button on:click=\\\"{onAddMeetup}\\\">",
		ctx
	});

	return block;
}

// (140:0) {#if filteredMeetups.length === 0}
function create_if_block_1$2(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("No meetups found!, Please add some.");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { id: true, class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, "No meetups found!, Please add some.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "id", "no-meetups");
			attr_dev(p, "class", "svelte-18e9u1f");
			add_location(p, file$7, 140, 2, 3234);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(140:0) {#if filteredMeetups.length === 0}",
		ctx
	});

	return block;
}

// (144:4) {#each filteredMeetups as meetup (meetup.id)}
function create_each_block(key_1, ctx) {
	let div;
	let meetupitem;
	let t;
	let div_transition;
	let rect;
	let stop_animation = noop;
	let current;

	meetupitem = new MeetupItem({
			props: {
				title: /*meetup*/ ctx[14].title,
				subtitle: /*meetup*/ ctx[14].subtitle,
				description: /*meetup*/ ctx[14].description,
				imageUrl: /*meetup*/ ctx[14].imageUrl,
				address: /*meetup*/ ctx[14].address,
				email: /*meetup*/ ctx[14].contactEmail,
				id: /*meetup*/ ctx[14].id,
				isFav: /*meetup*/ ctx[14].isFavorite
			},
			$$inline: true
		});

	meetupitem.$on("edit-meetup", /*onEditMeetup*/ ctx[7]);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = element("div");
			create_component(meetupitem.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(meetupitem.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$7, 144, 6, 3380);
			this.first = div;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(meetupitem, div, null);
			append_hydration_dev(div, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const meetupitem_changes = {};
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.title = /*meetup*/ ctx[14].title;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.subtitle = /*meetup*/ ctx[14].subtitle;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.description = /*meetup*/ ctx[14].description;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.imageUrl = /*meetup*/ ctx[14].imageUrl;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.address = /*meetup*/ ctx[14].address;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.email = /*meetup*/ ctx[14].contactEmail;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.id = /*meetup*/ ctx[14].id;
			if (dirty & /*filteredMeetups*/ 4) meetupitem_changes.isFav = /*meetup*/ ctx[14].isFavorite;
			meetupitem.$set(meetupitem_changes);
		},
		r: function measure() {
			rect = div.getBoundingClientRect();
		},
		f: function fix() {
			fix_position(div);
			stop_animation();
			add_transform(div, rect);
		},
		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div, rect, flip, { duration: 700 });
		},
		i: function intro(local) {
			if (current) return;
			transition_in(meetupitem.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(meetupitem.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, scale, {}, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(meetupitem);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(144:4) {#each filteredMeetups as meetup (meetup.id)}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let t0;
	let t1;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*editMode*/ ctx[0] === 'edit' && create_if_block_2(ctx);
	const if_block_creators = [create_if_block$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLoading*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-1t8qyrj\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			document.title = "Infinity Meetups";
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*editMode*/ ctx[0] === 'edit') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*editMode*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if_block1.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload(page) {
	// console.log(page);
	return this.fetch('https://vue-http-exmp-default-rtdb.firebaseio.com/meetups.json').then(res => {
		if (!res.ok) {
			throw new Error('Error fetching meetup data');
		}

		return res.json();
	}).then(data => {
		const loadedMeetups = [];

		for (const key in data) {
			loadedMeetups.push({ ...data[key], id: key });
		}

		// isError = null;
		// isLoading = false;
		return { fetchedMeetups: loadedMeetups.reverse() };
	}).catch(err => {
		// isError = err;
		// isLoading = false;
		this.error(500, 'Could not fetch meetups'); // meetups.setMeetups(loadedMeetups.reverse());
	}); // console.log(err.message);
}

function onErrorEditPage(event) {
	isError = {};
	isError.message = event.detail;
}

function instance$7($$self, $$props, $$invalidate) {
	let filteredMeetups;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Routes', slots, []);
	let { fetchedMeetups } = $$props;
	const dispatch = createEventDispatcher();
	let loadedMeetups = [];
	let favsOnly = false;
	let editMode;
	let editedId = null;
	let isLoading = false;
	let unsubscribe;

	// let isError = false;
	onMount(() => {
		unsubscribe = meetups.subscribe(items => {
			$$invalidate(10, loadedMeetups = items);
		});

		meetups.setMeetups(fetchedMeetups);
	});

	onDestroy(() => {
		if (unsubscribe) {
			unsubscribe();
		}
	});

	function selectComponent(event) {
		$$invalidate(11, favsOnly = event.detail === 'fav-meetup');
	}

	function onSaveMeetup() {
		$$invalidate(0, editMode = null);
		$$invalidate(1, editedId = null);
	}

	function cancelEdit() {
		$$invalidate(0, editMode = null);
		$$invalidate(1, editedId = null);
	}

	function onEditMeetup(event) {
		$$invalidate(0, editMode = 'edit');
		$$invalidate(1, editedId = event.detail);
	}

	function onAddMeetup() {
		$$invalidate(0, editMode = 'edit');
	}

	const writable_props = ['fetchedMeetups'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('fetchedMeetups' in $$props) $$invalidate(9, fetchedMeetups = $$props.fetchedMeetups);
	};

	$$self.$capture_state = () => ({
		preload,
		createEventDispatcher,
		onMount,
		onDestroy,
		scale,
		flip,
		meetups,
		MeetupItem,
		MeetupFilter,
		Button,
		EditMeetup,
		LoadingSpinner,
		fetchedMeetups,
		dispatch,
		loadedMeetups,
		favsOnly,
		editMode,
		editedId,
		isLoading,
		unsubscribe,
		selectComponent,
		onSaveMeetup,
		cancelEdit,
		onEditMeetup,
		onAddMeetup,
		onErrorEditPage,
		filteredMeetups
	});

	$$self.$inject_state = $$props => {
		if ('fetchedMeetups' in $$props) $$invalidate(9, fetchedMeetups = $$props.fetchedMeetups);
		if ('loadedMeetups' in $$props) $$invalidate(10, loadedMeetups = $$props.loadedMeetups);
		if ('favsOnly' in $$props) $$invalidate(11, favsOnly = $$props.favsOnly);
		if ('editMode' in $$props) $$invalidate(0, editMode = $$props.editMode);
		if ('editedId' in $$props) $$invalidate(1, editedId = $$props.editedId);
		if ('isLoading' in $$props) $$invalidate(3, isLoading = $$props.isLoading);
		if ('unsubscribe' in $$props) unsubscribe = $$props.unsubscribe;
		if ('filteredMeetups' in $$props) $$invalidate(2, filteredMeetups = $$props.filteredMeetups);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*favsOnly, loadedMeetups*/ 3072) {
			 $$invalidate(2, filteredMeetups = favsOnly
			? loadedMeetups.filter(m => m.isFavorite)
			: loadedMeetups);
		}
	};

	return [
		editMode,
		editedId,
		filteredMeetups,
		isLoading,
		selectComponent,
		onSaveMeetup,
		cancelEdit,
		onEditMeetup,
		onAddMeetup,
		fetchedMeetups,
		loadedMeetups,
		favsOnly
	];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { fetchedMeetups: 9 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*fetchedMeetups*/ ctx[9] === undefined && !('fetchedMeetups' in props)) {
			console.warn("<Routes> was created without expected prop 'fetchedMeetups'");
		}
	}

	get fetchedMeetups() {
		throw new Error_1$2("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fetchedMeetups(value) {
		throw new Error_1$2("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Routes;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguN2U3OWYwOWYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvZWFzaW5nL2luZGV4Lm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvdHJhbnNpdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2FuaW1hdGUvaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVUkvQmFkZ2Uuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvTWVldHVwL01lZXR1cEl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvTWVldHVwL01lZXR1cEZpbHRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9VSS9UZXh0SW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVUkvTW9kYWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2hlbHBlcnMvdmFsaWRhdGlvbi5qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01lZXR1cC9FZGl0TWVldHVwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1VJL0xvYWRpbmdTcGlubmVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5cbi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cbmZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5mdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbn1cbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gICAgY29uc3QgYSA9IDQuMCAvIDExLjA7XG4gICAgY29uc3QgYiA9IDguMCAvIDExLjA7XG4gICAgY29uc3QgYyA9IDkuMCAvIDEwLjA7XG4gICAgY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbiAgICBjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG4gICAgY29uc3QgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgcmV0dXJuIHQgPCBhXG4gICAgICAgID8gNy41NjI1ICogdDJcbiAgICAgICAgOiB0IDwgYlxuICAgICAgICAgICAgPyA5LjA3NSAqIHQyIC0gOS45ICogdCArIDMuNFxuICAgICAgICAgICAgOiB0IDwgY1xuICAgICAgICAgICAgICAgID8gY2EgKiB0MiAtIGNiICogdCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCAqIDIuMCkpXG4gICAgICAgIDogMC41ICogYm91bmNlT3V0KHQgKiAyLjAgLSAxLjApICsgMC41O1xufVxuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5mdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcbn1cbmZ1bmN0aW9uIGNpcmNJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5mdW5jdGlvbiBjaXJjT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGN1YmljSW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gICAgY29uc3QgZiA9IHQgLSAxLjA7XG4gICAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG4gICAgICAgIDogMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG4gICAgICAgICAgICAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAoTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMCk7XG59XG5mdW5jdGlvbiBleHBvSW5PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG4gICAgICAgID8gdFxuICAgICAgICA6IHQgPCAwLjVcbiAgICAgICAgICAgID8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuICAgICAgICAgICAgOiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuZnVuY3Rpb24gZXhwb0luKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBleHBvT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMS4wID8gdCA6IDEuMCAtIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KTtcbn1cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gICAgdCAvPSAwLjU7XG4gICAgaWYgKHQgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQ7XG4gICAgdC0tO1xuICAgIHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICAgIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICAgIHJldHVybiAtdCAqICh0IC0gMi4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gKzguMCAqIE1hdGgucG93KHQsIDQuMClcbiAgICAgICAgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xufVxuZnVuY3Rpb24gcXVpbnRJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5mdW5jdGlvbiBxdWludEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWludE91dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcbiAgICByZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cbmZ1bmN0aW9uIHNpbmVJbih0KSB7XG4gICAgY29uc3QgdiA9IE1hdGguY29zKHQgKiBNYXRoLlBJICogMC41KTtcbiAgICBpZiAoTWF0aC5hYnModikgPCAxZS0xNClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gMSAtIHY7XG59XG5mdW5jdGlvbiBzaW5lT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKHQgKiBNYXRoLlBJKSAvIDIpO1xufVxuXG5leHBvcnQgeyBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBjdWJpY0luLCBjdWJpY0luT3V0LCBjdWJpY091dCwgZWxhc3RpY0luLCBlbGFzdGljSW5PdXQsIGVsYXN0aWNPdXQsIGV4cG9JbiwgZXhwb0luT3V0LCBleHBvT3V0LCBxdWFkSW4sIHF1YWRJbk91dCwgcXVhZE91dCwgcXVhcnRJbiwgcXVhcnRJbk91dCwgcXVhcnRPdXQsIHF1aW50SW4sIHF1aW50SW5PdXQsIHF1aW50T3V0LCBzaW5lSW4sIHNpbmVJbk91dCwgc2luZU91dCB9O1xuIiwiaW1wb3J0IHsgY3ViaWNJbk91dCwgbGluZWFyLCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNfZnVuY3Rpb24sIGFzc2lnbiB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxuZnVuY3Rpb24gYmx1cihub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljSW5PdXQsIGFtb3VudCA9IDUsIG9wYWNpdHkgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IGYgPSBzdHlsZS5maWx0ZXIgPT09ICdub25lJyA/ICcnIDogc3R5bGUuZmlsdGVyO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX07IGZpbHRlcjogJHtmfSBibHVyKCR7dSAqIGFtb3VudH1weCk7YFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuICAgIGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuICAgIH07XG59XG5mdW5jdGlvbiBmbHkobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHsoMSAtIHQpICogeH1weCwgJHsoMSAtIHQpICogeX1weCk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9YFxuICAgIH07XG59XG5mdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5oZWlnaHQpO1xuICAgIGNvbnN0IHBhZGRpbmdfdG9wID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKTtcbiAgICBjb25zdCBwYWRkaW5nX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgY29uc3QgbWFyZ2luX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luVG9wKTtcbiAgICBjb25zdCBtYXJnaW5fYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIGNvbnN0IGJvcmRlcl90b3Bfd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBib3JkZXJfYm90dG9tX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogdCA9PiAnb3ZlcmZsb3c6IGhpZGRlbjsnICtcbiAgICAgICAgICAgIGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcbiAgICAgICAgICAgIGBoZWlnaHQ6ICR7dCAqIGhlaWdodH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLXRvcDogJHt0ICogcGFkZGluZ190b3B9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy1ib3R0b206ICR7dCAqIHBhZGRpbmdfYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi10b3A6ICR7dCAqIG1hcmdpbl90b3B9cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLWJvdHRvbTogJHt0ICogbWFyZ2luX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItdG9wLXdpZHRoOiAke3QgKiBib3JkZXJfdG9wX3dpZHRofXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci1ib3R0b20td2lkdGg6ICR7dCAqIGJvcmRlcl9ib3R0b21fd2lkdGh9cHg7YFxuICAgIH07XG59XG5mdW5jdGlvbiBzY2FsZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSAoc2QgKiB1KX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfVxuXHRcdGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0gPSB7fSkge1xuICAgIGxldCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5zdHJva2VMaW5lY2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgbGVuICs9IHBhcnNlSW50KHN0eWxlLnN0cm9rZVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYHN0cm9rZS1kYXNoYXJyYXk6ICR7dCAqIGxlbn0gJHt1ICogbGVufWBcbiAgICB9O1xufVxuZnVuY3Rpb24gY3Jvc3NmYWRlKF9hKSB7XG4gICAgdmFyIHsgZmFsbGJhY2sgfSA9IF9hLCBkZWZhdWx0cyA9IF9fcmVzdChfYSwgW1wiZmFsbGJhY2tcIl0pO1xuICAgIGNvbnN0IHRvX3JlY2VpdmUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbSwgbm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMzAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuICAgICAgICBjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgY29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7dCArICgxIC0gdCkgKiBkaH0pO1xuXHRcdFx0YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG4gICAgICAgIHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5zZXQocGFyYW1zLmtleSwge1xuICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3QgfSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2ZhZGUocmVjdCwgbm9kZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG4gICAgICAgICAgICAgICAgaXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLFxuICAgICAgICB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXG4gICAgXTtcbn1cblxuZXhwb3J0IHsgYmx1ciwgY3Jvc3NmYWRlLCBkcmF3LCBmYWRlLCBmbHksIHNjYWxlLCBzbGlkZSB9O1xuIiwiaW1wb3J0IHsgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gZmxpcChub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3QgW294LCBveV0gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW4uc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgY29uc3QgZHggPSAoZnJvbS5sZWZ0ICsgZnJvbS53aWR0aCAqIG94IC8gdG8ud2lkdGgpIC0gKHRvLmxlZnQgKyBveCk7XG4gICAgY29uc3QgZHkgPSAoZnJvbS50b3AgKyBmcm9tLmhlaWdodCAqIG95IC8gdG8uaGVpZ2h0KSAtICh0by50b3AgKyBveSk7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gKGQpID0+IE1hdGguc3FydChkKSAqIDEyMCwgZWFzaW5nID0gY3ViaWNPdXQgfSA9IHBhcmFtcztcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb246IGlzX2Z1bmN0aW9uKGR1cmF0aW9uKSA/IGR1cmF0aW9uKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpIDogZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeCA9IHUgKiBkeDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSB1ICogZHk7XG4gICAgICAgICAgICBjb25zdCBzeCA9IHQgKyB1ICogZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuICAgICAgICAgICAgY29uc3Qgc3kgPSB0ICsgdSAqIGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpIHNjYWxlKCR7c3h9LCAke3N5fSk7YDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IGZsaXAgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgc3BhbiB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIG1hcmdpbjogMCAuMjVyZW07XG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNjZjAwNTY7XG4gICAgYmFja2dyb3VuZDogI2NmMDA1NjtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgcGFkZGluZzogMCAuNXJlbTtcbiAgICBmb250LWZhbWlseTogJ0xhdG8nLCBzYW5zLXNlcmlmO1xuICAgIGZvbnQtc2l6ZTogLjhyZW07XG4gIH1cbjwvc3R5bGU+XG5cbjxzcGFuIHRyYW5zaXRpb246c2xpZGU+PHNsb3QvPjwvc3Bhbj4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBtZWV0dXBzIGZyb20gJy4uLy4uL3N0b3JlL21lZXR1cHMtc3RvcmUuanMnO1xuXG4gIGltcG9ydCBCdXR0b24gZnJvbSAnLi4vVUkvQnV0dG9uLnN2ZWx0ZSc7XG4gIGltcG9ydCBCYWRnZSBmcm9tICcuLi9VSS9CYWRnZS5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgdGl0bGU7XG4gIGV4cG9ydCBsZXQgc3VidGl0bGU7XG4gIGV4cG9ydCBsZXQgaW1hZ2VVcmw7XG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb247XG4gIGV4cG9ydCBsZXQgYWRkcmVzcztcbiAgZXhwb3J0IGxldCBlbWFpbDtcbiAgZXhwb3J0IGxldCBpZDtcbiAgZXhwb3J0IGxldCBpc0ZhdjtcblxuICBsZXQgaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBmdW5jdGlvbiBvblRvZ2dsZUZhdm9yaXRlKCkge1xuICAgIGlzTG9hZGluZyA9IHRydWU7XG4gICAgZmV0Y2goYGh0dHBzOi8vdnVlLWh0dHAtZXhtcC1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb20vbWVldHVwcy8ke2lkfS5qc29uYCwge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaXNGYXZvcml0ZTogIWlzRmF2fSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY2hhbmdpbmcgZmF2b3JpdGUgc3RhdHVzIScpO1xuICAgICAgICB9XG4gICAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBtZWV0dXBzLnRvZ2dsZUZhdm9yaXRlKGlkKTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgfSk7XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGFydGljbGUge1xuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMjYpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBtYXJnaW46IDFyZW07XG4gIH1cblxuICBoZWFkZXIsXG4gIC5jb250ZW50LFxuICBmb290ZXIge1xuICAgIHBhZGRpbmc6IDFyZW07XG4gIH1cblxuICAuaW1hZ2Uge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTRyZW07XG4gIH1cblxuICAuaW1hZ2UgaW1nIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgb2JqZWN0LWZpdDogY292ZXI7XG4gIH1cblxuICBoMSB7XG4gICAgZm9udC1zaXplOiAxLjI1cmVtO1xuICAgIG1hcmdpbjogMC41cmVtIDA7XG4gICAgZm9udC1mYW1pbHk6IFwiUm9ib3RvIFNsYWJcIiwgc2Fucy1zZXJpZjtcbiAgfVxuXG4gIGgxLmlzLWZhdm9yaXRlIHtcbiAgICBiYWNrZ3JvdW5kOiAjMDFhMTI5O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBwYWRkaW5nOiAwIDAuNXJlbTtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIH1cblxuICBoMiB7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGNvbG9yOiAjODA4MDgwO1xuICAgIG1hcmdpbjogMC41cmVtIDA7XG4gIH1cblxuICBwIHtcbiAgICBmb250LXNpemU6IDEuMjVyZW07XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgZGl2IHtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgfVxuXG4gIC5jaGFuZ2luZy1mYXYge1xuICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2NmMDA1NjtcbiAgICBiYWNrZ3JvdW5kOiAjY2YwMDU2O1xuICAgIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjI2KTtcbiAgICBjdXJzb3I6IHByb2dyZXNzO1xuICB9XG48L3N0eWxlPlxuXG48YXJ0aWNsZT5cbiAgPGhlYWRlcj5cbiAgICA8aDE+XG4gICAgICB7dGl0bGV9IFxuICAgICAgeyNpZiBpc0Zhdn1cbiAgICAgICAgPEJhZGdlPkZhdm9yaXRlPC9CYWRnZT5cbiAgICAgIHsvaWZ9XG4gICAgPC9oMT5cbiAgICA8aDI+e3N1YnRpdGxlfTwvaDI+XG4gICAgPHA+e2FkZHJlc3N9PC9wPlxuICA8L2hlYWRlcj5cbiAgPGRpdiBjbGFzcz1cImltYWdlXCI+XG4gICAgPGltZyBzcmM9XCJ7aW1hZ2VVcmx9XCIgYWx0PVwie3RpdGxlfVwiPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICA8cD57ZGVzY3JpcHRpb259PC9wPlxuICA8L2Rpdj5cbiAgPGZvb3Rlcj5cbiAgICA8IS0tIDxCdXR0b24gaHJlZj1cIm1haWx0bzp7ZW1haWx9XCI+Q29udGFjdDwvQnV0dG9uPiAtLT5cbiAgICA8QnV0dG9uIG1vZGU9XCJvdXRsaW5lXCIgdHlwZT1cImJ1dHRvblwiIG9uOmNsaWNrPVwie2Rpc3BhdGNoKCdlZGl0LW1lZXR1cCcsIGlkKX1cIj5FZGl0PC9CdXR0b24+XG4gICAgeyNpZiBpc0xvYWRpbmd9XG4gICAgICA8c3BhbiBjbGFzcz1cImNoYW5naW5nLWZhdlwiPntpc0Zhdj8gJ1VuZmF2b3JpdGluZycgOiAnRmF2b3JpdGluZycgfS4uLjwvc3Bhbj5cbiAgICB7OmVsc2V9XG4gICAgICA8QnV0dG9uIFxuICAgICAgICB0eXBlPVwiYnV0dG9uXCIgXG4gICAgICAgIG1vZGU9XCJvdXRsaW5lXCIgXG4gICAgICAgIGNvbG9yPXtpc0Zhdj8gbnVsbCA6ICdzdWNjZXNzJ31cbiAgICAgICAgb246Y2xpY2s9XCJ7b25Ub2dnbGVGYXZvcml0ZX1cIj5cbiAgICAgICAge2lzRmF2PyAnVW5mYXZvcml0ZScgOiAnRmF2b3JpdGUnfVxuICAgICAgPC9CdXR0b24+XG4gICAgey9pZn1cbiAgICA8QnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz1cInsoKSA9PiBkaXNwYXRjaCgnc2hvdy1kZXRhaWxzJywgaWQpfVwiPlNob3cgRGV0YWlsczwvQnV0dG9uPlxuICA8L2Zvb3Rlcj5cbjwvYXJ0aWNsZT4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgbGV0IHNlbGVjdGVkQnV0dG9uID0gJ2FsbC1tZWV0dXAnO1xuPC9zY3JpcHQ+XG5cbjxkaXY+XG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzOmFjdGl2ZT1cIntzZWxlY3RlZEJ1dHRvbiA9PT0gJ2FsbC1tZWV0dXAnfVwiXG4gIG9uOmNsaWNrPVwieygpID0+IHtcbiAgICBzZWxlY3RlZEJ1dHRvbiA9ICdhbGwtbWVldHVwJztcbiAgICBkaXNwYXRjaCgnc2VsZWN0LWNvbXBvbmVudCcsICdhbGwtbWVldHVwJyk7XG4gIH19XCI+QWxsPC9idXR0b24+XG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzOmFjdGl2ZT1cIntzZWxlY3RlZEJ1dHRvbiA9PT0gJ2Zhdi1tZWV0dXAnfVwiXG4gIG9uOmNsaWNrPVwieygpID0+IHtcbiAgICBzZWxlY3RlZEJ1dHRvbiA9ICdmYXYtbWVldHVwJztcbiAgICBkaXNwYXRjaCgnc2VsZWN0LWNvbXBvbmVudCcsICdmYXYtbWVldHVwJylcbiAgfX1cIj5GYXZvcml0ZTwvYnV0dG9uPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgZGl2IHtcbiAgICBmb250LXNpemU6IDBweDtcbiAgfVxuXG4gIGJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogI2FhYWFhYTtcbiAgICBmb250OiBpbmhlcml0O1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2FhYWFhYTtcbiAgICBwYWRkaW5nOiAwLjVyZW0gMXJlbTtcbiAgfVxuXG4gIGJ1dHRvbjpmb2N1cyB7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgfVxuXG4gIGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcbiAgICBib3JkZXItcmFkaXVzOiA1cHggMCAwIDVweDtcbiAgfVxuXG4gIGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xuICAgIGJvcmRlci1yYWRpdXM6IDAgNXB4IDVweCAwO1xuICB9XG5cbiAgYnV0dG9uOmhvdmVyLFxuICBidXR0b246YWN0aXZlLFxuICAuYWN0aXZlIHtcbiAgICBiYWNrZ3JvdW5kOiAjY2YwMDU2O1xuICAgIGJvcmRlci1jb2xvcjogI2NmMDA1NjtcbiAgICBjb2xvcjogd2hpdGU7XG4gIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBjb250cm9sVHlwZSA9IG51bGw7XG4gIGV4cG9ydCBsZXQgaWQ7XG4gIGV4cG9ydCBsZXQgbGFiZWw7XG4gIGV4cG9ydCBsZXQgcm93ID0gbnVsbDtcbiAgZXhwb3J0IGxldCBwbGFjZWhvbGRlcjtcbiAgZXhwb3J0IGxldCB2YWx1ZTtcbiAgZXhwb3J0IGxldCB0eXBlID0gJ3RleHQnO1xuICBleHBvcnQgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCB2YWxpZGl0eU1lc3NhZ2UgPSAnJztcblxuICBsZXQgdG91Y2hlZCA9IGZhbHNlO1xuPC9zY3JpcHQ+IFxuXG48ZGl2IGNsYXNzPVwiZm9ybS1jb250cm9sXCI+XG4gIDxsYWJlbCBmb3I9XCJ7aWR9XCI+e2xhYmVsfTwvbGFiZWw+XG4gIHsjaWYgY29udHJvbFR5cGUgPT09ICd0ZXh0YXJlYSd9XG4gICAgICA8dGV4dGFyZWEgbmFtZT1cIntpZH1cIiBjbGFzczppbnZhbGlkPVwieyF2YWxpZCAmJiB0b3VjaGVkfVwiIFxuICAgICAgICBpZD1cIntpZH1cIiByb3dzPVwie3Jvd31cIiBwbGFjZWhvbGRlcj1cIntwbGFjZWhvbGRlcn1cIiB2YWx1ZT1cInt2YWx1ZX1cIiBcbiAgICAgICAgb246aW5wdXQgb246Ymx1cj1cInsoKSA9PiB0b3VjaGVkID0gdHJ1ZX1cIiAvPiBcbiAgezplbHNlfVxuICAgICAgPGlucHV0IHR5cGU9XCJ7dHlwZX1cIiBuYW1lPVwie2lkfVwiIGNsYXNzOmludmFsaWQ9XCJ7IXZhbGlkICYmIHRvdWNoZWR9XCJcbiAgICAgICAgaWQ9XCJ7aWR9XCIgcGxhY2Vob2xkZXI9XCJ7cGxhY2Vob2xkZXJ9XCIgdmFsdWU9XCJ7dmFsdWV9XCIgXG4gICAgICAgIG9uOmlucHV0IG9uOmJsdXI9XCJ7KCkgPT4gdG91Y2hlZCA9IHRydWV9XCIgPlxuICB7L2lmfVxuXG4gIHsjaWYgdmFsaWRpdHlNZXNzYWdlICYmICF2YWxpZCAmJiB0b3VjaGVkfVxuICAgIDxwIGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPnt2YWxpZGl0eU1lc3NhZ2V9PC9wPlxuICB7L2lmfVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgaW5wdXQsXG4gIHRleHRhcmVhIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTAwJTtcbiAgICBmb250OiBpbmhlcml0O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgI2NjYztcbiAgICBib3JkZXItcmFkaXVzOiAzcHggM3B4IDAgMDtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBwYWRkaW5nOiAwLjE1cmVtIDAuMjVyZW07XG4gICAgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIDAuMXMgZWFzZS1vdXQ7XG4gIH1cblxuICBpbnB1dDpmb2N1cyxcbiAgdGV4dGFyZWE6Zm9jdXMge1xuICAgIGJvcmRlci1jb2xvcjogI2U0MDc2MztcbiAgICBvdXRsaW5lOiBub25lO1xuICB9XG5cbiAgbGFiZWwge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5mb3JtLWNvbnRyb2wge1xuICAgIHBhZGRpbmc6IDAuNXJlbSAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbjogMC4yNXJlbSAwO1xuICB9XG5cbiAgLmludmFsaWQge1xuICAgIGJvcmRlci1jb2xvcjogcmVkO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzMsIDE2MywgMTYzKTtcbiAgfVxuXG4gIC5lcnJvci1tZXNzYWdlIHtcbiAgICBjb2xvcjogcmVkO1xuICAgIG1hcmdpbjogLjI1cmVtIDA7XG4gIH1cbjwvc3R5bGU+XG5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGZseSwgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCB0aXRsZTtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGZ1bmN0aW9uIGNsb3NlTW9kYWwoKSB7XG4gICAgZGlzcGF0Y2goJ2NhbmNlbCcpO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAubW9kYWwtYmFja2Ryb3Age1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMHZoO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgei1pbmRleDogMTA7XG4gIH1cblxuICAubW9kYWwge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDEwdmg7XG4gICAgbGVmdDogMTAlO1xuICAgIHdpZHRoOiA4MCU7XG4gICAgbWF4LWhlaWdodDogODB2aDtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgei1pbmRleDogMTAwO1xuICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMjYpO1xuICAgIG92ZXJmbG93OiBhdXRvO1xuICB9XG5cbiAgaDEge1xuICAgIHBhZGRpbmc6IDFyZW07XG4gICAgbWFyZ2luOiAwO1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xuICAgIGZvbnQtZmFtaWx5OiAnUm9ib3RvIFNsYWInLCBzYW5zLXNlcmlmO1xuICB9XG5cbiAgLmNvbnRlbnQge1xuICAgIHBhZGRpbmc6IDFyZW07XG4gIH1cblxuICBmb290ZXIge1xuICAgIHBhZGRpbmc6IDFyZW07XG4gIH1cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAubW9kYWwge1xuICAgICAgd2lkdGg6IDQwcmVtO1xuICAgICAgbGVmdDogY2FsYyg1MCUgLSAyMHJlbSk7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2IHRyYW5zaXRpb246ZmFkZSBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wXCIgb246Y2xpY2s9XCJ7Y2xvc2VNb2RhbH1cIj48L2Rpdj5cbjxkaXYgdHJhbnNpdGlvbjpmbHk9XCJ7e3k6IDMwMH19XCIgY2xhc3M9XCJtb2RhbFwiPlxuICA8aDE+e3RpdGxlfTwvaDE+XG4gIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbiAgPGZvb3Rlcj5cbiAgICA8c2xvdCBuYW1lPVwiZm9vdGVyXCI+XG4gICAgICA8QnV0dG9uIG9uOmNsaWNrPVwie2Nsb3NlTW9kYWx9XCI+Q2xvc2U8L0J1dHRvbj5cbiAgICA8L3Nsb3Q+XG4gIDwvZm9vdGVyPlxuPC9kaXY+IiwiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsLCBsZW4pIHtcbiAgcmV0dXJuIHZhbC50cmltKCkubGVuZ3RoIDwgbGVuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEVtYWlsKHZhbCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICBcIlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzouW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8uKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XCJcbiAgKS50ZXN0KHZhbCk7XG59IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcblxuICBpbXBvcnQgbWVldHVwcyBmcm9tICcuLi8uLi9zdG9yZS9tZWV0dXBzLXN0b3JlLmpzJztcblxuICBpbXBvcnQgVGV4dElucHV0IGZyb20gJy4uL1VJL1RleHRJbnB1dC5zdmVsdGUnO1xuICBpbXBvcnQgQnV0dG9uIGZyb20gJy4uL1VJL0J1dHRvbi5zdmVsdGUnO1xuICBpbXBvcnQgTW9kYWwgZnJvbSAnLi4vVUkvTW9kYWwuc3ZlbHRlJztcblxuICBpbXBvcnQgeyBpc0VtcHR5LCBpc1ZhbGlkRW1haWwgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3ZhbGlkYXRpb24uanMnO1xuXG4gIGV4cG9ydCBsZXQgaWQgPSBudWxsO1xuXG4gIGxldCB0aXRsZSA9ICcnO1xuICBsZXQgc3VidGl0bGUgPSAnJztcbiAgbGV0IHVybCA9ICcnO1xuICBsZXQgYWRkcmVzcyA9ICcnO1xuICBsZXQgZGVzYyA9ICcnO1xuICBsZXQgZW1haWwgPSAnJztcblxuICAkOiBpc1RpdGxlVmFsaWQgPSAhaXNFbXB0eSh0aXRsZSwgMyk7XG4gICQ6IGlzU3VidGl0bGVWYWxpZCA9ICFpc0VtcHR5KHN1YnRpdGxlLCAzKTtcbiAgJDogaXNVcmxWYWxpZCA9ICFpc0VtcHR5KHVybCwgNSk7XG4gICQ6IGlzQWRkcmVzc1ZhbGlkID0gIWlzRW1wdHkoYWRkcmVzcywgMTApO1xuICAkOiBpc0Rlc2NWYWxpZCA9ICFpc0VtcHR5KGRlc2MsIDUpO1xuICAkOiBpc0VtYWlsVmFsaWQgPSBpc1ZhbGlkRW1haWwoZW1haWwpO1xuICAkOiBpc0Zvcm1WYWxpZCA9IGlzVGl0bGVWYWxpZCAmJiBpc1N1YnRpdGxlVmFsaWQgJiYgaXNVcmxWYWxpZCAmJiBpc0FkZHJlc3NWYWxpZCAmJiBpc0Rlc2NWYWxpZCAmIGlzRW1haWxWYWxpZDtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGlmKGlkKSB7XG4gICAgY29uc3QgdW5TdWIgPSBtZWV0dXBzLnN1YnNjcmliZShpdGVtcyA9PiB7XG4gICAgICBjb25zdCBtZWV0dXBUb0JlRWRpdGVkID0gaXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgIHRpdGxlID0gbWVldHVwVG9CZUVkaXRlZC50aXRsZTtcbiAgICAgIHN1YnRpdGxlID0gbWVldHVwVG9CZUVkaXRlZC5zdWJ0aXRsZTtcbiAgICAgIHVybCA9IG1lZXR1cFRvQmVFZGl0ZWQuaW1hZ2VVcmw7XG4gICAgICBhZGRyZXNzID0gbWVldHVwVG9CZUVkaXRlZC5hZGRyZXNzO1xuICAgICAgZGVzYyA9IG1lZXR1cFRvQmVFZGl0ZWQuZGVzY3JpcHRpb247XG4gICAgICBlbWFpbCA9IG1lZXR1cFRvQmVFZGl0ZWQuY29udGFjdEVtYWlsO1xuICAgIH0pO1xuXG4gICAgdW5TdWIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbmRpbmdFcnJvck1zZyhlcnJvck1zZykge1xuICAgIGRpc3BhdGNoKCdlcnJvci1tb2RhbCcsIGVycm9yTXNnKVxuICB9XG5cbiAgZnVuY3Rpb24gc3VibWl0Rm9ybSgpIHtcbiAgICBjb25zdCBtZWV0dXBEYXRhID0ge1xuICAgICAgdGl0bGUsXG4gICAgICBzdWJ0aXRsZSxcbiAgICAgIGltYWdlVXJsOiB1cmwsXG4gICAgICBkZXNjcmlwdGlvbjogZGVzYyxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBjb250YWN0RW1haWw6IGVtYWlsXG4gICAgfTtcblxuICAgIGlmKGlkKSB7XG4gICAgICBmZXRjaChgaHR0cHM6Ly92dWUtaHR0cC1leG1wLWRlZmF1bHQtcnRkYi5maXJlYmFzZWlvLmNvbS9tZWV0dXBzLyR7aWR9Lmpzb25gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobWVldHVwRGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZWRpdHRpbmcgbWVldHVwIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdNZWV0dXAgZWRpdHRlZCcpO1xuICAgICAgICBtZWV0dXBzLnVwZGF0ZU1lZXR1cChpZCwgbWVldHVwRGF0YSk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBzZW5kaW5nRXJyb3JNc2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhlcnIubWVzc2FnZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmV0Y2goJ2h0dHBzOi8vdnVlLWh0dHAtZXhtcC1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb20vbWVldHVwcy5qc29uJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoey4uLm1lZXR1cERhdGEsIGlzRmF2b3JpdGU6IGZhbHNlfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3Igc2F2aW5nIG1lZXR1cCEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNZWV0dXAgYWRkZWQgOicsIGRhdGEpO1xuICAgICAgICBtZWV0dXBzLmFkZE1lZXR1cCh7Li4ubWVldHVwRGF0YSwgaXNGYXZvcml0ZTogZmFsc2UsIGlkOiBkYXRhLm5hbWV9KTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHNlbmRpbmdFcnJvck1zZyhlcnIubWVzc2FnZSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goJ3NhdmUtZm9ybS1kYXRhJyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICBkaXNwYXRjaCgnY2FuY2VsJyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRlbGV0ZU1lZXR1cCgpIHtcbiAgICBmZXRjaChgaHR0cHM6Ly92dWUtaHR0cC1leG1wLWRlZmF1bHQtcnRkYi5maXJlYmFzZWlvLmNvbS9tZWV0dXBzLyR7aWR9Lmpzb25gLCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaWYoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZGVsZXRpbmcgbWVldHVwIScpO1xuICAgICAgICB9XG4gICAgICAgIG1lZXR1cHMuZGVsZXRlTWVldHVwKGlkKTtcbiAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIHNlbmRpbmdFcnJvck1zZyhlcnIubWVzc2FnZSk7XG4gICAgICB9KTtcbiAgICBkaXNwYXRjaCgnc2F2ZS1mb3JtLWRhdGEnKTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgZm9ybSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLyogbWF4LXdpZHRoOiA5MCU7XG4gICAgbWFyZ2luOiBhdXRvOyAqL1xuICB9XG48L3N0eWxlPlxuXG48TW9kYWwgdGl0bGU9XCJFZGl0IE1lZXR1cCBEYXRhXCIgb246Y2FuY2VsPlxuICA8Zm9ybSBvbjpzdWJtaXR8cHJldmVudERlZmF1bHQ9XCJ7c3VibWl0Rm9ybX1cIj5cbiAgICA8VGV4dElucHV0IFxuICAgICAgaWQ9XCJ0aXRsZVwiIFxuICAgICAgbGFiZWw9XCJUaXRsZVwiIFxuICAgICAgdmFsdWU9XCJ7dGl0bGV9XCIgXG4gICAgICB2YWxpZD1cIntpc1RpdGxlVmFsaWR9XCJcbiAgICAgIHZhbGlkaXR5TWVzc2FnZT1cIlBsZWFzZSBlbnRlciBhIHZhbGlkIHRpdGxlXCJcbiAgICAgIG9uOmlucHV0PVwieyhldmVudCkgPT4gKHRpdGxlID0gZXZlbnQudGFyZ2V0LnZhbHVlKX1cIiBcbiAgICAgIHBsYWNlaG9sZGVyPVwiWW91ciB0aXRsZSBnb2VzIGhlcmVcIi8+XG5cbiAgICA8VGV4dElucHV0IFxuICAgICAgaWQ9XCJzdWJ0aXRsZVwiIFxuICAgICAgbGFiZWw9XCJTdWJ0aXRsZVwiIFxuICAgICAgdmFsdWU9XCJ7c3VidGl0bGV9XCIgXG4gICAgICB2YWxpZD1cIntpc1N1YnRpdGxlVmFsaWR9XCJcbiAgICAgIHZhbGlkaXR5TWVzc2FnZT1cIlBsZWFzZSBlbnRlciBhIHZhbGlkIHN1YnRpdGxlXCJcbiAgICAgIG9uOmlucHV0PVwieyhldmVudCkgPT4gKHN1YnRpdGxlID0gZXZlbnQudGFyZ2V0LnZhbHVlKX1cIiBcbiAgICAgIHBsYWNlaG9sZGVyPVwiWW91ciBzdWJ0aXRsZSBnb2VzIGhlcmVcIi8+XG4gICAgXG4gICAgPFRleHRJbnB1dCBcbiAgICAgIGlkPVwiZGVzY3JpcHRpb25cIiBcbiAgICAgIGxhYmVsPVwiRGVzY3JpcHRpb25cIiBcbiAgICAgIHZhbHVlPVwie2Rlc2N9XCIgXG4gICAgICByb3c9XCIzXCJcbiAgICAgIHZhbGlkPVwie2lzRGVzY1ZhbGlkfVwiXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkZXNjcmlwdGlvblwiXG4gICAgICBjb250cm9sVHlwZT1cInRleHRhcmVhXCJcbiAgICAgIG9uOmlucHV0PVwieyhldmVudCkgPT4gKGRlc2MgPSBldmVudC50YXJnZXQudmFsdWUpfVwiIFxuICAgICAgcGxhY2Vob2xkZXI9XCJQbGVhc2UgYWRkIHNvbWUgZGVzY3JpcHRpb25cIi8+XG4gICAgXG4gICAgPFRleHRJbnB1dCBcbiAgICAgIGlkPVwiaW1hZ2VVcmxcIiBcbiAgICAgIGxhYmVsPVwiaW1hZ2VVcmxcIiBcbiAgICAgIHZhbHVlPVwie3VybH1cIiBcbiAgICAgIHR5cGU9XCJ1cmxcIlxuICAgICAgdmFsaWQ9XCJ7aXNVcmxWYWxpZH1cIlxuICAgICAgdmFsaWRpdHlNZXNzYWdlPVwiUGxlYXNlIGVudGVyIGEgdmFsaWQgaW1hZ2UgdXJsXCJcbiAgICAgIG9uOmlucHV0PVwieyhldmVudCkgPT4gKHVybCA9IGV2ZW50LnRhcmdldC52YWx1ZSl9XCIgXG4gICAgICBwbGFjZWhvbGRlcj1cIlBsZWFzZSBhZGQgaW1hZ2UgdXJsXCIvPlxuICAgIFxuICAgIDxUZXh0SW5wdXQgXG4gICAgICBpZD1cImFkZHJlc3NcIiBcbiAgICAgIGxhYmVsPVwiQWRkcmVzc1wiIFxuICAgICAgdmFsdWU9XCJ7YWRkcmVzc31cIiBcbiAgICAgIHJvdz1cIjNcIlxuICAgICAgdmFsaWQ9XCJ7aXNBZGRyZXNzVmFsaWR9XCJcbiAgICAgIHZhbGlkaXR5TWVzc2FnZT1cIlBsZWFzZSBlbnRlciBhIHZhbGlkIGFkZHJlc3NcIlxuICAgICAgY29udHJvbFR5cGU9XCJ0ZXh0YXJlYVwiXG4gICAgICBvbjppbnB1dD1cInsoZXZlbnQpID0+IChhZGRyZXNzID0gZXZlbnQudGFyZ2V0LnZhbHVlKX1cIiBcbiAgICAgIHBsYWNlaG9sZGVyPVwiWW91ciBhZGRyZXNzIGdvZXMgaGVyZVwiLz5cbiAgICBcbiAgICA8VGV4dElucHV0IFxuICAgICAgaWQ9XCJlbWFpbFwiIFxuICAgICAgbGFiZWw9XCJlbWFpbFwiIFxuICAgICAgdmFsdWU9XCJ7ZW1haWx9XCIgXG4gICAgICB0eXBlPVwiZW1haWxcIlxuICAgICAgdmFsaWQ9XCJ7aXNFbWFpbFZhbGlkfVwiXG4gICAgICB2YWxpZGl0eU1lc3NhZ2U9XCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbFwiXG4gICAgICBvbjppbnB1dD1cInsoZXZlbnQpID0+IChlbWFpbCA9IGV2ZW50LnRhcmdldC52YWx1ZSl9XCIgXG4gICAgICBwbGFjZWhvbGRlcj1cIllvdXIgZS1tYWlsIElkIGdvZXMgaGVyZVwiLz5cbiAgPC9mb3JtPlxuICA8ZGl2IHNsb3Q9XCJmb290ZXJcIj5cbiAgICA8QnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBtb2RlPVwib3V0bGluZVwiIG9uOmNsaWNrPVwie29uQ2FuY2VsfVwiID5DYW5jZWw8L0J1dHRvbj5cbiAgICA8QnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBvbjpjbGljaz1cIntzdWJtaXRGb3JtfVwiIGRpc2FibGVkPVwieyFpc0Zvcm1WYWxpZH1cIiA+U2F2ZTwvQnV0dG9uPlxuICAgIHsjaWYgaWR9XG4gICAgICA8QnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz1cIntvbkRlbGV0ZU1lZXR1cH1cIj5EZWxldGU8L0J1dHRvbj5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbjwvTW9kYWw+IiwiPGRpdiBjbGFzcz1cImxvYWRpbmctc3Bpbm5lclwiPlxuICA8ZGl2IGNsYXNzPVwibGRzLWZhY2Vib29rXCI+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAubG9hZGluZy1zcGlubmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgbWFyZ2luOiAycmVtO1xuICAgIC8qIGhlaWdodDogMTAwdmg7ICovXG4gIH1cblxuICAubGRzLWZhY2Vib29rIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiA4MHB4O1xuICAgIGhlaWdodDogODBweDtcbiAgfVxuICAubGRzLWZhY2Vib29rIGRpdiB7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiA4cHg7XG4gICAgd2lkdGg6IDE2cHg7XG4gICAgYmFja2dyb3VuZDogI2NmMDA1NjtcbiAgICBhbmltYXRpb246IGxkcy1mYWNlYm9vayAxLjJzIGN1YmljLWJlemllcigwLCAwLjUsIDAuNSwgMSkgaW5maW5pdGU7XG4gIH1cbiAgLmxkcy1mYWNlYm9vayBkaXY6bnRoLWNoaWxkKDEpIHtcbiAgICBsZWZ0OiA4cHg7XG4gICAgYW5pbWF0aW9uLWRlbGF5OiAtMC4yNHM7XG4gIH1cbiAgLmxkcy1mYWNlYm9vayBkaXY6bnRoLWNoaWxkKDIpIHtcbiAgICBsZWZ0OiAzMnB4O1xuICAgIGFuaW1hdGlvbi1kZWxheTogLTAuMTJzO1xuICB9XG4gIC5sZHMtZmFjZWJvb2sgZGl2Om50aC1jaGlsZCgzKSB7XG4gICAgbGVmdDogNTZweDtcbiAgICBhbmltYXRpb24tZGVsYXk6IDA7XG4gIH1cbiAgQGtleWZyYW1lcyBsZHMtZmFjZWJvb2sge1xuICAgIDAlIHtcbiAgICAgIHRvcDogOHB4O1xuICAgICAgaGVpZ2h0OiA2NHB4O1xuICAgIH1cbiAgICA1MCUsIDEwMCUge1xuICAgICAgdG9wOiAyNHB4O1xuICAgICAgaGVpZ2h0OiAzMnB4O1xuICAgIH1cbiAgfVxuPC9zdHlsZT4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGZ1bmN0aW9uIHByZWxvYWQocGFnZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKHBhZ2UpO1xuICAgIHJldHVybiB0aGlzLmZldGNoKCdodHRwczovL3Z1ZS1odHRwLWV4bXAtZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tL21lZXR1cHMuanNvbicpLnRoZW4ocmVzID0+IHtcbiAgICAgIGlmKCFyZXMub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBtZWV0dXAgZGF0YScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlZE1lZXR1cHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbG9hZGVkTWVldHVwcy5wdXNoKHtcbiAgICAgICAgICAuLi5kYXRhW2tleV0sXG4gICAgICAgICAgaWQ6IGtleVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGlzRXJyb3IgPSBudWxsO1xuICAgICAgLy8gaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4ge2ZldGNoZWRNZWV0dXBzOiBsb2FkZWRNZWV0dXBzLnJldmVyc2UoKX07XG4gICAgICAvLyBtZWV0dXBzLnNldE1lZXR1cHMobG9hZGVkTWVldHVwcy5yZXZlcnNlKCkpO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAvLyBpc0Vycm9yID0gZXJyO1xuICAgICAgLy8gaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmVycm9yKDUwMCwgJ0NvdWxkIG5vdCBmZXRjaCBtZWV0dXBzJyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhlcnIubWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQsIG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IHNjYWxlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnO1xuXG4gIGltcG9ydCBtZWV0dXBzIGZyb20gJy4uL3N0b3JlL21lZXR1cHMtc3RvcmUuanMnO1xuXG4gIGltcG9ydCBNZWV0dXBJdGVtIGZyb20gJy4uL2NvbXBvbmVudHMvTWVldHVwL01lZXR1cEl0ZW0uc3ZlbHRlJztcbiAgaW1wb3J0IE1lZXR1cEZpbHRlciBmcm9tICcuLi9jb21wb25lbnRzL01lZXR1cC9NZWV0dXBGaWx0ZXIuc3ZlbHRlJztcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9jb21wb25lbnRzL1VJL0J1dHRvbi5zdmVsdGUnO1xuICBpbXBvcnQgRWRpdE1lZXR1cCBmcm9tICcuLi9jb21wb25lbnRzL01lZXR1cC9FZGl0TWVldHVwLnN2ZWx0ZSc7XG4gIGltcG9ydCBMb2FkaW5nU3Bpbm5lciBmcm9tICcuLi9jb21wb25lbnRzL1VJL0xvYWRpbmdTcGlubmVyLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBmZXRjaGVkTWVldHVwcztcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBsb2FkZWRNZWV0dXBzID0gW107XG4gIGxldCBmYXZzT25seSA9IGZhbHNlO1xuICBsZXQgZWRpdE1vZGU7XG4gIGxldCBlZGl0ZWRJZCA9IG51bGw7XG4gIGxldCBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICAvLyBsZXQgaXNFcnJvciA9IGZhbHNlO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIHVuc3Vic2NyaWJlID0gbWVldHVwcy5zdWJzY3JpYmUoaXRlbXMgPT4ge1xuICAgICAgbG9hZGVkTWVldHVwcyA9IGl0ZW1zO1xuICAgIH0pO1xuICAgIG1lZXR1cHMuc2V0TWVldHVwcyhmZXRjaGVkTWVldHVwcyk7XG4gIH0pO1xuXG4gIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgaWYodW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KTtcblxuICAkOiBmaWx0ZXJlZE1lZXR1cHMgPSBmYXZzT25seSA/IGxvYWRlZE1lZXR1cHMuZmlsdGVyKG0gPT4gbS5pc0Zhdm9yaXRlKSA6IGxvYWRlZE1lZXR1cHM7XG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29tcG9uZW50KGV2ZW50KSB7XG4gICAgZmF2c09ubHkgPSBldmVudC5kZXRhaWwgPT09ICdmYXYtbWVldHVwJztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2F2ZU1lZXR1cCgpIHtcbiAgICBlZGl0TW9kZSA9IG51bGw7XG4gICAgZWRpdGVkSWQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsRWRpdCgpIHtcbiAgICBlZGl0TW9kZSA9IG51bGw7XG4gICAgZWRpdGVkSWQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FZGl0TWVldHVwKGV2ZW50KSB7XG4gICAgZWRpdE1vZGUgPSAnZWRpdCc7XG4gICAgZWRpdGVkSWQgPSBldmVudC5kZXRhaWw7XG4gIH1cblxuICBmdW5jdGlvbiBvbkFkZE1lZXR1cCgpIHtcbiAgICBlZGl0TW9kZSA9ICdlZGl0JztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3JFZGl0UGFnZShldmVudCkge1xuICAgIGlzRXJyb3IgPSB7fTtcbiAgICBpc0Vycm9yLm1lc3NhZ2UgPSBldmVudC5kZXRhaWw7XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gICNtZWV0dXBzIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyO1xuICAgIGdyaWQtZ2FwOiAxcmVtO1xuICB9XG5cbiAgI21lZXR1cC1jb250cm9scyB7XG4gICAgbWFyZ2luOiAxcmVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG5cbiAgI25vLW1lZXR1cHMge1xuICAgIG1hcmdpbjogMXJlbTtcbiAgfVxuXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuICAgICNtZWV0dXBzIHtcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIDFmcik7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5JbmZpbml0eSBNZWV0dXBzPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbnsjaWYgZWRpdE1vZGUgPT09ICdlZGl0J31cbiAgPEVkaXRNZWV0dXAgaWQ9e2VkaXRlZElkfSBvbjpzYXZlLWZvcm0tZGF0YT17b25TYXZlTWVldHVwfSBvbjpjYW5jZWw9XCJ7Y2FuY2VsRWRpdH1cIlxuICBvbjplcnJvci1tb2RhbD1cIntvbkVycm9yRWRpdFBhZ2V9XCIgLz5cbnsvaWZ9XG5cbnsjaWYgaXNMb2FkaW5nfVxuICA8TG9hZGluZ1NwaW5uZXIvPlxuezplbHNlfVxuICA8c2VjdGlvbiBpZD1cIm1lZXR1cC1jb250cm9sc1wiPlxuICAgIDxNZWV0dXBGaWx0ZXIgb246c2VsZWN0LWNvbXBvbmVudD1cIntzZWxlY3RDb21wb25lbnR9XCIgLz5cbiAgICA8QnV0dG9uIG9uOmNsaWNrPVwie29uQWRkTWVldHVwfVwiPk5ldyBNZWV0dXA8L0J1dHRvbj5cbiAgPC9zZWN0aW9uPlxueyNpZiBmaWx0ZXJlZE1lZXR1cHMubGVuZ3RoID09PSAwfVxuICA8cCBpZD1cIm5vLW1lZXR1cHNcIj5ObyBtZWV0dXBzIGZvdW5kISwgUGxlYXNlIGFkZCBzb21lLjwvcD5cbnsvaWZ9XG4gIDxzZWN0aW9uIGlkPVwibWVldHVwc1wiPlxuICAgIHsjZWFjaCBmaWx0ZXJlZE1lZXR1cHMgYXMgbWVldHVwIChtZWV0dXAuaWQpfVxuICAgICAgPGRpdiB0cmFuc2l0aW9uOnNjYWxlIGFuaW1hdGU6ZmxpcD1cInt7ZHVyYXRpb246IDcwMH19XCI+XG4gICAgICAgIDxNZWV0dXBJdGVtIHRpdGxlPXttZWV0dXAudGl0bGV9IHN1YnRpdGxlPXttZWV0dXAuc3VidGl0bGV9IGRlc2NyaXB0aW9uPXttZWV0dXAuZGVzY3JpcHRpb259XG4gICAgICAgIGltYWdlVXJsPXttZWV0dXAuaW1hZ2VVcmx9IGFkZHJlc3M9e21lZXR1cC5hZGRyZXNzfSBlbWFpbD17bWVldHVwLmNvbnRhY3RFbWFpbH0gXG4gICAgICAgIGlkPXttZWV0dXAuaWR9IGlzRmF2PXttZWV0dXAuaXNGYXZvcml0ZX0gb246ZWRpdC1tZWV0dXA9XCJ7b25FZGl0TWVldHVwfVwiLz5cbiAgICAgIDwvZGl2PlxuICAgIHsvZWFjaH1cbiAgPC9zZWN0aW9uPlxuey9pZn1cblxuIl0sIm5hbWVzIjpbImxpbmVhciJdLCJtYXBwaW5ncyI6Ijs7O0FBNkRBLFNBQVMsUUFBUSxDQUFDLENBQUMsRUFBRTtBQUNyQixJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDdEIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMzQjs7QUN0QkEsU0FBUyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsR0FBRyxFQUFFLE1BQU0sR0FBR0EsUUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3pFLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDOUMsSUFBSSxPQUFPO0FBQ1gsUUFBUSxLQUFLO0FBQ2IsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsTUFBTTtBQUNkLFFBQVEsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckMsS0FBSyxDQUFDO0FBQ04sQ0FBQztBQUNELFNBQVMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLEdBQUcsRUFBRSxNQUFNLEdBQUcsUUFBUSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxPQUFPLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3JHLElBQUksTUFBTSxLQUFL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
